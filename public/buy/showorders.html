<!DOCTYPE html>
<html>

<head>
    <title>TandoorBaaz Orders Management</title>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <style>
        .order-card {
            margin-bottom: 20px;
            border: none;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s;
        }

        .order-card:hover {
            transform: translateY(-5px);
        }

        .order-actions {
            display: flex;
            gap: 10px;
        }

        .status-badge {
            position: absolute;
            top: 10px;
            right: 10px;
        }

        .delay-badge {
            position: absolute;
            top: 10px;
            left: 10px;
        }

        .kitchen-item {
            transition: all 0.3s;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }

        .kitchen-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .kitchen-item.bg-danger {
            animation: pulse-urgent 1.5s infinite;
        }

        @keyframes pulse-urgent {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.8;
            }

            100% {
                opacity: 1;
            }
        }

        /* Delay level badge colors for pending status */
        .delay-level-0 {
            background-color: hsl(120, 80%, 50%);
            color: white;
        }

        .delay-level-1 {
            background-color: hsl(96, 80%, 50%);
            color: white;
        }

        .delay-level-2 {
            background-color: hsl(72, 80%, 50%);
            color: white;
        }

        .delay-level-3 {
            background-color: hsl(48, 80%, 50%);
            color: white;
        }

        .delay-level-4 {
            background-color: hsl(24, 80%, 50%);
            color: white;
        }

        .delay-level-5 {
            background-color: hsl(0, 80%, 50%);
            color: white;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }

        .alert-pulse {
            animation: pulse 1s infinite;
        }

        /* Delay comparison table styles */
        #delayComparisonTable table {
            font-size: 0.9rem;
        }

        #delayComparisonTable .badge {
            font-size: 0.8rem;
            padding: 0.35em 0.65em;
        }

        /* Highlight styles for order cards */
        .order-card.highlight-danger {
            box-shadow: 0 0 0 3px #dc3545, 0 2px 10px rgba(0, 0, 0, 0.1);
            transform: translateY(-5px);
            transition: all 0.3s ease;
            background-color: rgba(220, 53, 69, 0.25);
        }

        .order-card.highlight-warning {
            box-shadow: 0 0 0 3px #ffc107, 0 2px 10px rgba(0, 0, 0, 0.1);
            transform: translateY(-5px);
            transition: all 0.3s ease;
            background-color: rgba(255, 193, 7, 0.25);
        }

        .order-card.highlight-info {
            box-shadow: 0 0 0 3px #0dcaf0, 0 2px 10px rgba(0, 0, 0, 0.1);
            transform: translateY(-5px);
            transition: all 0.3s ease;
            background-color: rgba(13, 202, 240, 0.25);
        }

        .order-card.highlight-light {
            box-shadow: 0 0 0 3px #f8f9fa, 0 2px 10px rgba(0, 0, 0, 0.1);
            transform: translateY(-5px);
            transition: all 0.3s ease;
            background-color: rgba(248, 249, 250, 0.5);
        }

        /* Pulsating animation for highlighted cards */
        @keyframes highlight-pulse {
            0% {
                box-shadow: 0 0 0 3px rgba(255, 193, 7, 0.9), 0 2px 10px rgba(0, 0, 0, 0.2);
                transform: translateY(-5px) scale(1);
            }

            50% {
                box-shadow: 0 0 0 6px rgba(255, 193, 7, 0.7), 0 4px 15px rgba(0, 0, 0, 0.3);
                transform: translateY(-7px) scale(1.02);
            }

            100% {
                box-shadow: 0 0 0 3px rgba(255, 193, 7, 0.9), 0 2px 10px rgba(0, 0, 0, 0.2);
                transform: translateY(-5px) scale(1);
            }
        }

        .order-card.highlight-pulse {
            animation: highlight-pulse 1.5s infinite;
        }

        /* Additional border styles for highlighted cards */
        .order-card.highlight-danger .card-body {
            border: 2px solid rgba(220, 53, 69, 0.7);
            border-radius: 4px;
        }

        .order-card.highlight-warning .card-body {
            border: 2px solid rgba(255, 193, 7, 0.7);
            border-radius: 4px;
        }

        .order-card.highlight-info .card-body {
            border: 2px solid rgba(13, 202, 240, 0.7);
            border-radius: 4px;
        }

        .order-card.highlight-light .card-body {
            border: 2px solid rgba(108, 117, 125, 0.7);
            border-radius: 4px;
        }

        /* Kitchen badge hover effect */
        .kitchen-badge {
            transition: all 0.2s ease;
        }

        .kitchen-badge:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .kitchen-badge.active {
            transform: scale(1.1);
            box-shadow: 0 0 0 2px #fff, 0 2px 5px rgba(0, 0, 0, 0.3);
            position: relative;
            z-index: 10;
        }

        /* Delay comparison row active state */
        .delay-comparison-row {
            transition: all 0.2s ease;
        }

        .delay-comparison-row:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .delay-comparison-row.active {
            box-shadow: inset 0 0 0 2px #0dcaf0;
            position: relative;
            z-index: 2;
        }

        /* Search results count styling */
        #searchResultsCount {
            font-weight: bold;
        }

        /* Search highlight for matching text */
        .search-highlight {
            background-color: rgba(255, 193, 7, 0.3);
            padding: 0 2px;
            border-radius: 2px;
        }
    </style>
</head>

<body>
    <div class="container-fluid mt-4">
        <div class="row">
            <div class="col-md-8">
                <div class="d-flex justify-content-between align-items-center mb-4">
                    <div>
                        <h2>Pending Orders</h2>
                        <small class="text-muted"><i class="bi bi-sort-down"></i> Orders sorted by delay (most delayed
                            first)</small>
                    </div>
                    <div>
                        <button class="btn btn-success me-2" data-bs-toggle="modal" data-bs-target="#addOrderModal">
                            <i class="bi bi-plus-circle"></i> Add Order
                        </button>
                        <button class="btn btn-primary me-2" onclick="loadOrders()">
                            <i class="bi bi-arrow-clockwise"></i> Refresh
                        </button>
                        <button class="btn btn-info" id="toggleDelayComparisonBtn">
                            <i class="bi bi-clock-history"></i> Delay Comparison
                        </button>
                    </div>
                </div>
                <!-- Search Bar -->
                <div class="card mb-4">
                    <div class="card-body">
                        <div class="input-group">
                            <span class="input-group-text"><i class="bi bi-search"></i></span>
                            <input type="text" class="form-control" id="orderSearchInput"
                                placeholder="Search by phone number or comments...">
                            <button class="btn btn-outline-secondary" type="button" id="clearSearchBtn">
                                <i class="bi bi-x-circle"></i> Clear
                            </button>
                        </div>
                        <div class="form-text mt-2">
                            <span id="searchResultsCount">0</span> orders found matching your search
                        </div>
                    </div>
                </div>
                <div id="delayComparisonContainer" class="mb-4" style="display: none;">
                    <div class="card">
                        <div class="card-header bg-info text-white d-flex justify-content-between align-items-center">
                            <h5 class="mb-0">Order Delay Comparison</h5>
                            <div>
                                <button class="btn btn-sm btn-light me-2" onclick="showDelayComparison()">
                                    <i class="bi bi-arrow-clockwise"></i> Refresh
                                </button>
                                <button class="btn btn-sm btn-danger" onclick="debugDelayComparison()">
                                    <i class="bi bi-bug"></i> Debug
                                </button>
                            </div>
                        </div>
                        <div class="card-body">
                            <div id="delayComparisonTable"></div>
                        </div>
                    </div>
                </div>
                <div id="pendingOrdersList" class="row"></div>
            </div>

            <div class="col-md-4">
                <div class="card sticky-top" style="top: 20px;">
                    <div class="card-header bg-dark text-white d-flex justify-content-between align-items-center">
                        <div>
                            <h5 class="mb-0"><i class="bi bi-fire"></i> Priority Cooking List</h5>
                            <small class="text-light"><i class="bi bi-sort-down"></i> Sorted by delay priority</small>
                        </div>
                        <div>
                            <span class="badge bg-danger me-2">Cook in Order</span>
                            <button class="btn btn-sm btn-outline-light me-1" onclick="renderKitchenList()">
                                <i class="bi bi-arrow-clockwise"></i>
                            </button>
                            <button class="btn btn-sm btn-outline-light" onclick="debugKitchenList()">
                                <i class="bi bi-bug"></i>
                            </button>
                        </div>
                    </div>
                    <div class="card-body" id="kitchenList"></div>
                </div>
            </div>
        </div>

        <!-- Completed Orders Sections -->
        <div class="row mt-4">
            <!-- Paid Orders Section -->
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header bg-success text-white d-flex justify-content-between align-items-center">
                        <h5 class="mb-0"><i class="bi bi-cash-coin"></i> Paid Orders</h5>
                        <button class="btn btn-sm btn-outline-light" onclick="toggleSection('paidOrdersSection')">
                            <i class="bi bi-chevron-down" id="paidOrdersToggleIcon"></i>
                        </button>
                    </div>
                    <div class="card-body" id="paidOrdersSection">
                        <div id="paidOrdersList" class="row"></div>
                    </div>
                </div>
            </div>

            <!-- Delivered Orders Section -->
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header bg-info text-white d-flex justify-content-between align-items-center">
                        <h5 class="mb-0"><i class="bi bi-truck"></i> Delivered Orders</h5>
                        <button class="btn btn-sm btn-outline-light" onclick="toggleSection('deliveredOrdersSection')">
                            <i class="bi bi-chevron-down" id="deliveredOrdersToggleIcon"></i>
                        </button>
                    </div>
                    <div class="card-body" id="deliveredOrdersSection">
                        <div id="deliveredOrdersList" class="row"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div class="modal fade" id="addOrderModal" tabindex="-1" aria-labelledby="addOrderModalLabel">
        <div class="modal-dialog">
            <div class="modal-content">
                <form id="addOrderForm">
                    <div class="modal-header">
                        <h5 class="modal-title" id="addOrderModalLabel">Add Order</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <div class="mb-3">
                            <label for="customerPhone" class="form-label">Customer Phone</label>
                            <input type="tel" class="form-control" id="customerPhone"
                                placeholder="Enter phone number (optional)">
                        </div>
                        <div class="mb-3">
                            <label for="customerComments" class="form-label">Customer Comments</label>
                            <textarea class="form-control" id="customerComments"
                                placeholder="Enter vehicle or house info (optional)"></textarea>
                        </div>
                        <div id="orderItemsContainer">
                            <!-- Order items will be added here -->
                        </div>
                        <button type="button" class="btn btn-secondary mb-3" id="addOrderItemBtn">Add Item</button>
                        <div class="mb-3">
                            <strong>Total: ₹<span id="orderTotal">0</span></strong>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="submit" class="btn btn-primary" id="saveOrderBtn" data-bs-dismiss="modal">Save
                            Order</button>
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <div class="modal fade" id="editOrderModal" tabindex="-1" aria-labelledby="editOrderModalLabel">
        <div class="modal-dialog">
            <div class="modal-content">
                <form id="editOrderForm">
                    <div class="modal-header">
                        <h5 class="modal-title" id="editOrderModalLabel">Edit Order</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <div class="mb-3">
                            <label for="editCustomerPhone" class="form-label">Customer Phone</label>
                            <input type="tel" class="form-control" id="editCustomerPhone"
                                placeholder="Enter phone number (optional)">
                        </div>
                        <div class="mb-3">
                            <label for="editCustomerComments" class="form-label">Customer Comments</label>
                            <textarea class="form-control" id="editCustomerComments"
                                placeholder="Enter vehicle or house info (optional)"></textarea>
                        </div>
                        <div id="editOrderItemsContainer">
                            <!-- Edit order items will be added here -->
                        </div>
                        <button type="button" class="btn btn-secondary mb-3" id="editAddOrderItemBtn">Add Item</button>
                        <div class="mb-3">
                            <strong>Total: ₹<span id="editOrderTotal">0</span></strong>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="submit" class="btn btn-primary">Update Order</button>
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <div class="modal fade" id="vehicleModal" tabindex="-1" aria-labelledby="vehicleModalLabel">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="vehicleModalLabel">Vehicle Number</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <input type="text" id="vehicleNumberInput" class="form-control" placeholder="Enter vehicle number">
                </div>
                <div class="modal-footer">
                    <button type="button" id="saveVehicleNumberBtn" class="btn btn-primary">Save Vehicle Number</button>
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="delayAlertModal" tabindex="-1" aria-labelledby="delayAlertModalLabel">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header bg-danger text-white">
                    <h5 class="modal-title" id="delayAlertModalLabel">Delay Alert</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"
                        aria-label="Close"></button>
                </div>
                <div class="modal-body" id="delayAlertContent">
                    <!-- Delay alert content will be injected here -->
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    <button type="button" class="btn btn-primary" onclick="sendDelayMessage()">Send WhatsApp
                        Message</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Firebase Configuration and Initialization
        const firebaseConfig = {
            apiKey: "AIzaSyAEKHWdRyzI8WyBeGeesjDrM-nEzOXCuNk",
            authDomain: "billion1-a9324.firebaseapp.com",
            projectId: "billion1-a9324",
            storageBucket: "billion1-a9324.appspot.com",
            messagingSenderId: "443716692865",
            appId: "1:443716692865:web:96813fe32a44f8342cd680",
            measurementId: "G-FE7NFHY5PG"
        };

        const app = firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();

        // Application State
        let state = {
            currentOrders: [],
            filteredOrders: [],
            searchQuery: '',
            editingOrderId: null,
            vehicleOrderId: null,
            alertedOrders: new Set(),
            currentDelayOrder: null,
            menuItems: {
                1: {
                    name: "Seekh Kebab",
                    portions: {
                        half: { name: "HALF", price: 109 },
                        full: { name: "FULL", price: 209 },
                    },
                },
                2: {
                    name: "Chicken Tikka",
                    portions: {
                        half: { name: "HALF", price: 149 },
                        full: { name: "FULL", price: 289 },
                    },
                },
                3: {
                    name: "Afghani Chicken Tikka",
                    portions: {
                        half: { name: "HALF", price: 169 },
                        full: { name: "FULL", price: 329 },
                    },
                },
                4: {
                    name: "Tandoori Chicken",
                    portions: {
                        half: { name: "HALF", price: 169 },
                        full: { name: "FULL", price: 329 },
                    },
                },
                5: {
                    name: "Afghani Chicken",
                    portions: {
                        half: { name: "HALF", price: 199 },
                        full: { name: "FULL", price: 389 },
                    },
                },
                6: {
                    name: "Chicken Wings",
                    portions: {
                        half: { name: "HALF", price: 129 },
                        full: { name: "FULL", price: 249 },
                    },
                },
                7: {
                    name: "Chicken Tangdi",
                    portions: {
                        half: { name: "HALF", price: 99 },
                        full: { name: "FULL", price: 189 },
                    },
                },
                8: {
                    name: "Afghani Tangdi",
                    portions: {
                        half: { name: "HALF", price: 119 },
                        full: { name: "FULL", price: 229 },
                    },
                },
                9: {
                    name: "Masala Chaap",
                    portions: {
                        half: { name: "HALF", price: 69 },
                        full: { name: "FULL", price: 129 },
                    },
                },
                10: {
                    name: "Malai Chaap",
                    portions: {
                        half: { name: "HALF", price: 79 },
                        full: { name: "FULL", price: 149 },
                    },
                },
                11: {
                    name: "Afghani Chaap",
                    portions: {
                        half: { name: "HALF", price: 89 },
                        full: { name: "FULL", price: 169 },
                    },
                },
                12: {
                    name: "Paneer Tikka",
                    portions: {
                        half: { name: "HALF", price: 79 },
                        full: { name: "FULL", price: 149 },
                    },
                },
                13: {
                    name: "Romali Roti",
                    portions: {
                        piece: { name: "PER PIECE", price: 10 },
                    },
                },
            }
        };

        // Initialize Application
        document.addEventListener('DOMContentLoaded', () => {
            initModals();
            initEventListeners();
            initSectionToggles();
            loadOrders();
            setInterval(checkDelayedOrders, 300000); // 5 minute checks

            // Update elapsed times every minute
            setInterval(() => {
                updateUI();
            }, 60000);

            // Show delay comparison on page load
            setTimeout(() => {
                document.getElementById('delayComparisonContainer').style.display = 'block';
                showDelayComparison();
                // Debug the delay comparison to ensure it's working
                console.log("Initial delay comparison setup complete");
            }, 2000); // Longer delay to ensure orders are fully loaded
        });

        function initSectionToggles() {
            // Initialize section toggle icons
            document.getElementById('paidOrdersToggleIcon').classList.add('bi-chevron-down');
            document.getElementById('deliveredOrdersToggleIcon').classList.add('bi-chevron-down');

            // Initially collapse the completed order sections on mobile
            if (window.innerWidth < 768) {
                toggleSection('paidOrdersSection');
                toggleSection('deliveredOrdersSection');
            }
        }

        function initModals() {
            // Initialize modals with proper options
            state.modals = {
                edit: new bootstrap.Modal(document.getElementById('editOrderModal'), {
                    backdrop: true,
                    keyboard: true,
                    focus: true
                }),
                vehicle: new bootstrap.Modal(document.getElementById('vehicleModal'), {
                    backdrop: true,
                    keyboard: true,
                    focus: true
                }),
                delay: new bootstrap.Modal(document.getElementById('delayAlertModal'), {
                    backdrop: true,
                    keyboard: true,
                    focus: true
                }),
                addOrder: new bootstrap.Modal(document.getElementById('addOrderModal'), {
                    backdrop: true,
                    keyboard: true,
                    focus: true
                }),
                editOrder: new bootstrap.Modal(document.getElementById('editOrderModal'), {
                    backdrop: true,
                    keyboard: true,
                    focus: true
                })
            };

            // Add event listeners to handle modal cleanup
            document.getElementById('addOrderModal').addEventListener('hidden.bs.modal', function () {
                // Clean up any leftover backdrop or body classes
                const backdrop = document.querySelector('.modal-backdrop');
                if (backdrop) backdrop.parentNode.removeChild(backdrop);
                document.body.classList.remove('modal-open');
                document.body.style.removeProperty('padding-right');
                document.body.style.removeProperty('overflow');
            });
        }

        function initEventListeners() {
            document.getElementById('saveVehicleNumberBtn').addEventListener('click', saveVehicleNumber);
            document.getElementById('addOrderForm').addEventListener('submit', handleNewOrder);
            document.getElementById('editOrderForm').addEventListener('submit', handleOrderEdit);
            document.getElementById('editAddOrderItemBtn').addEventListener('click', () => {
                const row = createEditOrderItemRow();
                document.getElementById('editOrderItemsContainer').appendChild(row);
            });
            document.getElementById('toggleDelayComparisonBtn').addEventListener('click', toggleDelayComparison);

            // Add a global click handler for document to clear highlights when clicking elsewhere
            document.addEventListener('click', function (event) {
                if (!event.target.closest('.kitchen-badge') &&
                    !event.target.closest('.delay-comparison-row') &&
                    !event.target.closest('.order-card.highlight-danger, .order-card.highlight-warning, .order-card.highlight-info, .order-card.highlight-light')) {
                    clearOrderHighlights();
                }
            });
        }

        async function loadOrders() {
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            db.collection('bot_orders')
                .where('createdAt', '>=', today)
                .orderBy('createdAt', 'desc')
                .onSnapshot(handleOrderSnapshot);
        }

        function handleOrderSnapshot(snapshot) {
            console.log("Order snapshot received, document count:", snapshot.docs.length);

            // Process orders and update state
            state.currentOrders = snapshot.docs.map(doc => {
                const data = doc.data();
                console.log(`Order ${doc.id} - status: ${data.status}, updatedAt raw:`, data.updatedAt);
                // Ensure updatedAt is a Date object
                let updatedAtDate = null;
                if (data.updatedAt) {
                    if (typeof data.updatedAt.toDate === 'function') {
                        updatedAtDate = data.updatedAt.toDate();
                    } else if (data.updatedAt instanceof Date) {
                        updatedAtDate = data.updatedAt;
                    } else {
                        console.warn(`Order ${doc.id} has updatedAt in unexpected format:`, data.updatedAt);
                        updatedAtDate = null;
                    }
                }

                const order = {
                    docId: doc.id,
                    ...data,
                    createdAt: data.createdAt ? (typeof data.createdAt.toDate === 'function' ? data.createdAt.toDate() : data.createdAt) : null,
                    updatedAt: updatedAtDate,
                    // Ensure items is always an array
                    items: Array.isArray(data.items) ? data.items : []
                };

                // Calculate delay level for each order
                order.delayLevel = calculateDelayLevel(order);

                return order;
            });

            // Sort orders by delay level in descending order (most delayed first)
            state.currentOrders.sort((a, b) => b.delayLevel - a.delayLevel);

            // Initialize filtered orders with all orders
            if (state.searchQuery) {
                // If there's an active search, apply it to the new orders
                searchOrders(state.searchQuery);
            } else {
                state.filteredOrders = [...state.currentOrders];
                document.getElementById('searchResultsCount').textContent = state.currentOrders.length;
            }

            // Log the sorted orders to verify they're in the correct order
            console.log("Orders sorted by delay level:", state.currentOrders.map(o => ({
                id: o.docId,
                delayLevel: o.delayLevel,
                status: o.status
            })));

            // Clean up alerts for orders that are no longer active
            state.currentOrders.forEach(order => {
                if (order.status !== 'preparing' && state.alertedOrders.has(order.docId)) {
                    console.log(`Clearing alert for order ${order.docId} as it's now ${order.status}`);
                    state.alertedOrders.delete(order.docId);

                    // If this was the current delay order, close the modal
                    if (state.currentDelayOrder && state.currentDelayOrder.docId === order.docId) {
                        console.log(`Closing delay alert modal for order ${order.docId}`);
                        state.currentDelayOrder = null;
                        const delayAlertModal = bootstrap.Modal.getInstance(document.getElementById('delayAlertModal'));
                        if (delayAlertModal) {
                            delayAlertModal.hide();
                        }
                    }
                }
            });

            updateUI();
            checkDelayedOrders();
        }

        function updateUI() {
            console.log("Updating UI...");
            console.log("Current orders count:", state.currentOrders.length);

            // Count orders by status
            const statusCounts = state.currentOrders.reduce((acc, order) => {
                acc[order.status] = (acc[order.status] || 0) + 1;
                return acc;
            }, {});
            console.log("Orders by status:", statusCounts);

            renderOrders();
            renderKitchenList();

            // Update delay comparison if it's visible
            if (document.getElementById('delayComparisonContainer').style.display !== 'none') {
                showDelayComparison();
            }
        }

        function searchOrders(query) {
            const searchCard = document.querySelector('.card:has(#orderSearchInput)');

            if (!query || query.trim() === '') {
                state.searchQuery = '';
                state.filteredOrders = [...state.currentOrders];
                document.getElementById('searchResultsCount').textContent = state.currentOrders.length;

                // Remove active search styling
                if (searchCard) {
                    searchCard.classList.remove('border-primary');
                    searchCard.style.boxShadow = '';
                }
                return;
            }

            query = query.toLowerCase().trim();
            state.searchQuery = query;

            state.filteredOrders = state.currentOrders.filter(order => {
                // Search in phone number
                const phoneMatch = order.customerDetails &&
                    order.customerDetails.phone &&
                    order.customerDetails.phone.toLowerCase().includes(query);

                // Search in comments
                const commentsMatch = order.customerDetails &&
                    order.customerDetails.comments &&
                    order.customerDetails.comments.toLowerCase().includes(query);

                return phoneMatch || commentsMatch;
            });

            // Update the search results count
            document.getElementById('searchResultsCount').textContent = state.filteredOrders.length;

            // Add active search styling
            if (searchCard) {
                searchCard.classList.add('border-primary');
                searchCard.style.boxShadow = '0 0 0 0.25rem rgba(13, 110, 253, 0.25)';
            }
        }

        function renderOrders() {
            // Use filtered orders if search is active, otherwise use all orders
            const ordersToRender = state.searchQuery ? state.filteredOrders : state.currentOrders;

            // Verify orders are still sorted by delay level
            console.log("Orders at render time:", ordersToRender.map(o => ({
                id: o.docId,
                delayLevel: o.delayLevel,
                status: o.status
            })));

            // Separate orders by status
            const pendingOrders = ordersToRender.filter(order =>
                order.status === 'preparing' || order.status === 'pending');

            const paidOrders = ordersToRender.filter(order =>
                order.status === 'paid(online)' || order.status === 'paid (cash)');

            const deliveredOrders = ordersToRender.filter(order =>
                order.status === 'delivered');

            // Function to generate order card HTML
            const generateOrderCard = (order, isCompact = false) => `
                <div class="${isCompact ? 'col-md-6' : 'col-md-6 col-lg-4'}">
                    <div id="order-${order.docId}" class="card order-card" style="border-left: 5px solid ${getDelayColor(order)}">
                        <div class="card-body ${isCompact ? 'p-3' : ''}">
                            <span class="badge ${getStatusClass(order.status)} status-badge">${order.status}</span>
                            ${order.delayLevel > 0 ? `<span class="badge bg-danger delay-badge">Delayed ${order.delayLevel}x</span>` : ''}
                            <h5 class="card-title">Order #${(order.id ? order.id.toString() : order.docId).slice(-4)}</h5>
                            <p class="mb-1"><i class="bi bi-phone"></i> ${highlightSearchMatch(order.customerDetails.phone, state.searchQuery)}</p>
                            <p class="mb-1"><i class="bi bi-chat-left-text"></i> ${highlightSearchMatch(order.customerDetails.comments || '', state.searchQuery)}</p>
                            <p class="mb-1" title="Order time: ${formatTime(order.createdAt)}"><i class="bi bi-hourglass-split"></i> <strong>${formatElapsedTime(order.createdAt)}</strong></p>
                            ${order.vehicleNumber ? `<p class="mb-1"><i class="bi bi-truck"></i> ${order.vehicleNumber}</p>` : ''}
                            <hr>
                            ${order.items.map(item => `
                                <div class="d-flex justify-content-between mb-2 order-item" data-dish="${item.name}" data-portion="${item.portion.toLowerCase()}">
                                    <div>${item.name} (${item.portion}) ×${item.quantity}</div>
                                    <div>₹${item.price * item.quantity}</div>
                                </div>
                            `).join('')}
                            <hr>
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <strong>Total:</strong>
                                <h5 class="mb-0">₹${order.total}</h5>
                            </div>
                            <div class="order-actions d-flex flex-column gap-2">
                                <div>
                                    <label for="statusSelect-${order.docId}" class="form-label visually-hidden">Status</label>
                                    <select id="statusSelect-${order.docId}" class="form-select form-select-sm" onchange="updateOrderStatus('${order.docId}', this.value)">
                                        <option value="preparing" ${order.status === 'preparing' ? 'selected' : ''}>Preparing</option>
                                        <option value="delivered" ${order.status === 'delivered' ? 'selected' : ''}>Delivered</option>
                                        <option value="paid(online)" ${order.status === 'paid(online)' ? 'selected' : ''}>Paid (Online)</option>
                                        <option value="paid (cash)" ${order.status === 'paid (cash)' ? 'selected' : ''}>Paid (Cash)</option>
                                    </select>
                                </div>
                                <button class="btn btn-primary btn-sm" onclick="showEditModal('${order.docId}')">
                                    <i class="bi bi-pencil"></i> Edit
                                </button>
                                <button class="btn btn-danger btn-sm" onclick="deleteOrder('${order.docId}')">
                                    <i class="bi bi-trash"></i> Delete
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Render pending orders
            const pendingOrdersHTML = pendingOrders.length > 0
                ? pendingOrders.map(order => generateOrderCard(order, false)).join('')
                : `<div class="col-12"><div class="alert alert-info">No pending orders at this time.</div></div>`;

            // Render paid orders
            const paidOrdersHTML = paidOrders.length > 0
                ? paidOrders.map(order => generateOrderCard(order, true)).join('')
                : `<div class="col-12"><div class="alert alert-info">No paid orders at this time.</div></div>`;

            // Render delivered orders
            const deliveredOrdersHTML = deliveredOrders.length > 0
                ? deliveredOrders.map(order => generateOrderCard(order, true)).join('')
                : `<div class="col-12"><div class="alert alert-info">No delivered orders at this time.</div></div>`;

            // Update the DOM
            document.getElementById('pendingOrdersList').innerHTML = pendingOrdersHTML;
            document.getElementById('paidOrdersList').innerHTML = paidOrdersHTML;
            document.getElementById('deliveredOrdersList').innerHTML = deliveredOrdersHTML;

            // Update counters in section headers
            updateSectionCounters(pendingOrders.length, paidOrders.length, deliveredOrders.length);
        }

        function updateSectionCounters(pendingCount, paidCount, deliveredCount) {
            // Add count badges to section headers
            const paidHeader = document.querySelector('.card-header:has(+ #paidOrdersSection) h5');
            const deliveredHeader = document.querySelector('.card-header:has(+ #deliveredOrdersSection) h5');

            if (paidHeader) {
                paidHeader.innerHTML = `<i class="bi bi-cash-coin"></i> Paid Orders <span class="badge bg-light text-dark ms-2">${paidCount}</span>`;
            }

            if (deliveredHeader) {
                deliveredHeader.innerHTML = `<i class="bi bi-truck"></i> Delivered Orders <span class="badge bg-light text-dark ms-2">${deliveredCount}</span>`;
            }
        }

        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            const iconId = sectionId === 'paidOrdersSection' ? 'paidOrdersToggleIcon' : 'deliveredOrdersToggleIcon';
            const icon = document.getElementById(iconId);

            if (section.style.display === 'none') {
                section.style.display = 'block';
                icon.classList.replace('bi-chevron-up', 'bi-chevron-down');
            } else {
                section.style.display = 'none';
                icon.classList.replace('bi-chevron-down', 'bi-chevron-up');
            }
        }

        function renderKitchenList() {
            console.log("Rendering kitchen list...");

            // Aggregate quantities by dish name and portion
            const kitchenItems = state.currentOrders
                .filter(o => {
                    // Only include orders with 'preparing' or 'pending' status that have items
                    const valid = (o.status === 'preparing' || o.status === 'pending') &&
                        o.items && Array.isArray(o.items) && o.items.length > 0;

                    if (!valid && (o.status === 'preparing' || o.status === 'pending')) {
                        console.warn(`Order ${o.docId} has status ${o.status} but no valid items:`, o.items);
                    }

                    return valid;
                })
                .flatMap(o => {
                    // Add order information to each item for better tracking
                    console.log(`Processing order ${o.docId} with ${o.items.length} items`);
                    return o.items.map(item => ({
                        ...item,
                        orderId: o.docId,
                        orderTime: o.createdAt,
                        delayLevel: o.delayLevel || 0,
                        orderStatus: o.status
                    }));
                })
                .reduce((acc, item) => {
                    if (!acc[item.name]) {
                        acc[item.name] = {
                            half: 0,
                            full: 0,
                            delayLevels: [],
                            orderTimes: [],
                            priority: 0,
                            orderIds: new Set()
                        };
                    }
                    const portionKey = item.portion.toLowerCase();
                    if (portionKey === 'half' || portionKey === 'full') {
                        acc[item.name][portionKey] += item.quantity;
                    } else {
                        // For other portions, accumulate under 'full' as default
                        acc[item.name].full += item.quantity;
                    }

                    // Track delay level for priority calculation
                    acc[item.name].delayLevels.push(item.delayLevel);

                    // Track order time for sorting by oldest orders
                    if (item.orderTime) {
                        acc[item.name].orderTimes.push(item.orderTime);
                    }

                    // Track unique order IDs
                    acc[item.name].orderIds.add(item.orderId);

                    return acc;
                }, {});

            // Calculate priority score for each dish
            Object.values(kitchenItems).forEach(item => {
                // Priority factors:
                // 1. Maximum delay level (most important)
                // 2. Number of orders containing this dish
                // 3. Age of oldest order containing this dish

                const maxDelay = item.delayLevels.length > 0 ? Math.max(...item.delayLevels) : 0;
                const orderCount = item.orderIds.size;

                // Find oldest order time
                let oldestOrderAge = 0;
                if (item.orderTimes.length > 0) {
                    const oldestTime = new Date(Math.min(...item.orderTimes.map(t => t.getTime())));
                    oldestOrderAge = (new Date() - oldestTime) / 60000; // in minutes
                }

                // Calculate priority score (higher is more urgent)
                item.priority = (maxDelay * 100) + (orderCount * 10) + Math.min(oldestOrderAge / 5, 20);
            });

            // Generate HTML grouped by dish with priority indicators
            const kitchenHTML = Object.entries(kitchenItems)
                // Sort by priority score (highest first)
                .sort((a, b) => b[1].priority - a[1].priority)
                .map(([name, portions]) => {
                    const halfQty = portions.half;
                    const fullQty = portions.full;
                    const maxDelay = portions.delayLevels.length > 0 ? Math.max(...portions.delayLevels) : 0;
                    const orderCount = portions.orderIds.size;

                    // Determine priority level (0-3)
                    let priorityLevel = 0;
                    if (maxDelay >= 3) priorityLevel = 3;
                    else if (maxDelay >= 1) priorityLevel = 2;
                    else if (orderCount > 1) priorityLevel = 1;

                    // Priority styling
                    let priorityClass = '';
                    let priorityBadge = '';
                    let borderStyle = '';

                    switch (priorityLevel) {
                        case 3: // Critical priority
                            priorityClass = 'bg-danger text-white';
                            priorityBadge = ''; // Removed badge
                            borderStyle = 'border-left: 5px solid #dc3545;';
                            break;
                        case 2: // High priority
                            priorityClass = 'bg-warning';
                            priorityBadge = ''; // Removed badge
                            borderStyle = 'border-left: 5px solid #ffc107;';
                            break;
                        case 1: // Medium priority
                            priorityClass = 'bg-info text-dark';
                            priorityBadge = ''; // Removed badge
                            borderStyle = 'border-left: 5px solid #0dcaf0;';
                            break;
                        default: // Normal priority
                            priorityClass = 'bg-light';
                            borderStyle = '';
                    }

                    // Get status badges for this item
                    const statusCounts = Array.from(portions.orderIds).reduce((acc, orderId) => {
                        const order = state.currentOrders.find(o => o.docId === orderId);
                        if (order) {
                            acc[order.status] = (acc[order.status] || 0) + 1;
                        }
                        return acc;
                    }, {});

                    const statusBadges = Object.entries(statusCounts).map(([status, count]) =>
                        `<span class="badge ${getStatusClass(status)}">${status}: ${count}</span>`
                    ).join(' ');

                    return `
                    <div class="kitchen-item mb-3 p-2 rounded position-relative ${priorityClass}" style="${borderStyle}">
                        <div class="d-flex justify-content-between align-items-center">
                            <h5 class="mb-0">${name}</h5>
                            <span class="badge bg-dark">${orderCount} order${orderCount !== 1 ? 's' : ''}</span>
                        </div>
                        <div class="d-flex justify-content-between mt-2">
                            ${halfQty > 0 ? `<div class="badge bg-secondary p-2 kitchen-badge" data-dish="${name}" data-portion="half" data-orders='${JSON.stringify(Array.from(portions.orderIds))}' data-priority="${priorityLevel}" style="cursor: pointer;" title="Click to highlight related orders">Half: ${halfQty}</div>` : ''}
                            ${fullQty > 0 ? `<div class="badge bg-secondary p-2 kitchen-badge" data-dish="${name}" data-portion="full" data-orders='${JSON.stringify(Array.from(portions.orderIds))}' data-priority="${priorityLevel}" style="cursor: pointer;" title="Click to highlight related orders">Full: ${fullQty}</div>` : ''}
                        </div>
                        <div class="mt-2">
                            ${statusBadges}
                        </div>
                        ${priorityLevel >= 2 ? `<div class="progress mt-2" style="height: 5px;">
                            <div class="progress-bar bg-danger" role="progressbar" style="width: 100%"></div>
                        </div>` : ''}
                    </div>
                    `;
                }).join('');

            // Calculate total dishes to prepare
            const totalDishes = Object.values(kitchenItems).reduce((sum, item) => sum + item.half + item.full, 0);

            // Add a header with priority legend and total count
            const legendHTML = `
                <div class="alert alert-dark mb-3">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <h6 class="mb-0">Priority Legend:</h6>
                        <span class="badge bg-secondary">${totalDishes} dishes to prepare</span>
                    </div>
                    <div class="d-flex flex-wrap gap-2">
                        <span class="badge bg-danger">URGENT - Cook First</span>
                        <span class="badge bg-warning">HIGH - Cook Next</span>
                        <span class="badge bg-info text-dark">NEXT - Prepare Soon</span>
                        <span class="badge bg-light text-dark">Normal</span>
                    </div>
                </div>
            `;

            // Check if there are any items to display
            if (Object.keys(kitchenItems).length === 0) {
                document.getElementById('kitchenList').innerHTML = `
                    <div class="alert alert-info">
                        <i class="bi bi-info-circle"></i> No items to prepare at this time.
                    </div>
                `;
            } else {
                document.getElementById('kitchenList').innerHTML = legendHTML + kitchenHTML;

                // Add event listeners to kitchen badges
                setTimeout(() => {
                    document.querySelectorAll('.kitchen-badge').forEach(badge => {
                        badge.addEventListener('click', handleKitchenBadgeClick);
                    });
                }, 100);
            }
        }

        // Function to handle kitchen badge clicks
        function handleKitchenBadgeClick(event) {
            // Clear any previous highlights
            clearOrderHighlights();

            const badge = event.currentTarget;

            // Remove active class from all badges
            document.querySelectorAll('.kitchen-badge.active').forEach(b => {
                b.classList.remove('active');
            });

            // Add active class to the clicked badge
            badge.classList.add('active');

            const dishName = badge.getAttribute('data-dish');
            const portion = badge.getAttribute('data-portion');
            const orderIds = JSON.parse(badge.getAttribute('data-orders'));
            const priorityLevel = parseInt(badge.getAttribute('data-priority'));

            // Determine highlight class based on priority level
            let highlightClass = 'highlight-light';
            if (priorityLevel === 3) {
                highlightClass = 'highlight-danger';
            } else if (priorityLevel === 2) {
                highlightClass = 'highlight-warning';
            } else if (priorityLevel === 1) {
                highlightClass = 'highlight-info';
            }

            // Highlight the related orders
            orderIds.forEach(orderId => {
                const orderCard = document.getElementById(`order-${orderId}`);
                if (orderCard) {
                    // Add highlight classes to the order card
                    orderCard.classList.add(highlightClass);
                    orderCard.classList.add('highlight-pulse');

                    // Scroll to the first highlighted order
                    if (orderIds.indexOf(orderId) === 0) {
                        orderCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }

                    // Bold the specific dish items within the order
                    const orderItems = orderCard.querySelectorAll(`.order-item[data-dish="${dishName}"]`);
                    orderItems.forEach(item => {
                        // Check if the portion matches or if we should highlight all portions of this dish
                        if (item.getAttribute('data-portion') === portion || portion === 'all') {
                            // Make the text bold and add a background
                            const itemText = item.querySelector('div:first-child');
                            if (itemText) {
                                itemText.style.fontWeight = 'bold';
                                itemText.style.color = '#000';
                                itemText.style.backgroundColor = 'rgba(255, 193, 7, 0.3)';
                                itemText.style.padding = '3px 6px';
                                itemText.style.borderRadius = '4px';
                            }
                        }
                    });
                }
            });

            // Set a timeout to clear highlights after 5 seconds
            setTimeout(clearOrderHighlights, 5000);
        }

        // Function to handle delay comparison row clicks
        function handleDelayComparisonRowClick(event) {
            // Clear any previous highlights
            clearOrderHighlights();

            const row = event.currentTarget;

            // Remove active class from all rows
            document.querySelectorAll('.delay-comparison-row.active').forEach(r => {
                r.classList.remove('active');
            });

            // Add active class to the clicked row
            row.classList.add('active');

            const orderId = row.getAttribute('data-order-id');
            const delayLevel = parseInt(row.getAttribute('data-delay-level'));

            // Determine highlight class based on delay level
            let highlightClass = 'highlight-light';
            if (delayLevel >= 3) {
                highlightClass = 'highlight-danger';
            } else if (delayLevel >= 1) {
                highlightClass = 'highlight-warning';
            }

            // Highlight the related order
            const orderCard = document.getElementById(`order-${orderId}`);
            if (orderCard) {
                // Add highlight classes to the order card
                orderCard.classList.add(highlightClass);
                orderCard.classList.add('highlight-pulse');

                // Scroll to the highlighted order
                orderCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }

            // Set a timeout to clear highlights after 5 seconds
            setTimeout(clearOrderHighlights, 5000);
        }

        // Function to clear all order highlights
        function clearOrderHighlights() {
            document.querySelectorAll('.order-card.highlight-danger, .order-card.highlight-warning, .order-card.highlight-info, .order-card.highlight-light, .order-card.highlight-pulse').forEach(card => {
                card.classList.remove('highlight-danger', 'highlight-warning', 'highlight-info', 'highlight-light', 'highlight-pulse');
            });

            // Reset any styled text in order items
            document.querySelectorAll('.order-item div').forEach(item => {
                item.style.fontWeight = '';
                item.style.color = '';
                item.style.backgroundColor = '';
                item.style.padding = '';
                item.style.borderRadius = '';
            });

            document.querySelectorAll('.kitchen-badge.active').forEach(badge => {
                badge.classList.remove('active');
            });

            document.querySelectorAll('.delay-comparison-row.active').forEach(row => {
                row.classList.remove('active');
            });
        }

        // Delay Handling Functions
        function checkDelayedOrders() {
            console.log('Checking delayed orders...');

            // Only check active orders (pending or preparing)
            const activeOrders = state.currentOrders.filter(order =>
                ['pending', 'preparing'].includes(order.status)
            );

            activeOrders.forEach(order => {
                // Use the already calculated delay level from handleOrderSnapshot
                // or recalculate if needed
                if (order.delayLevel === undefined) {
                    order.delayLevel = calculateDelayLevel(order);
                }

                console.log(`Order ${order.docId} delayLevel: ${order.delayLevel}`);

                if (order.delayLevel > 0 && !state.alertedOrders.has(order.docId)) {
                    console.log(`Handling delayed order ${order.docId}`);
                    handleDelayedOrder(order);
                }
            });

            // Update the delay comparison if it's visible
            if (document.getElementById('delayComparisonContainer').style.display !== 'none') {
                showDelayComparison();
            }
        }

        function calculateDelayLevel(order) {
            // Use the new calculateExactDelay function for consistency
            return calculateExactDelay(order).delayLevel;
        }

        function handleDelayedOrder(order) {
            console.log(`Adding order ${order.docId} to alertedOrders and showing delay alert.`);
            state.alertedOrders.add(order.docId);
            showDelayAlert(order);
        }

        function showDelayAlert(order) {
            console.log(`Checking if we should show delay alert for order ${order.docId}`);

            // Only show alerts for preparing orders
            if (order.status !== 'preparing') {
                console.log(`Skipping delay alert for order ${order.docId} with status ${order.status}`);
                return;
            }

            console.log(`Showing delay alert for order ${order.docId}`);
            state.currentDelayOrder = order;
            let delayMinutes = 0;
            if (order.updatedAt instanceof Date) {
                delayMinutes = Math.floor((Date.now() - order.updatedAt.getTime()) / 60000);
            }

            // Update the modal content
            document.getElementById('delayAlertContent').innerHTML = `
        <div class="alert alert-danger">
            <h5><i class="bi bi-exclamation-triangle-fill me-2"></i>Order #${(order.id ? order.id.toString() : order.docId).slice(-4)} delayed!</h5>
            <p><strong>Status:</strong> ${order.status} for ${delayMinutes} minutes</p>
            <p><strong>Note:</strong> This alert will automatically close if the order is marked as delivered, paid(online), or paid (cash).</p>
        </div>
    `;

            // Show the modal
            try {
                if (state.modals && state.modals.delay) {
                    state.modals.delay.show();
                } else {
                    // Fallback if modal isn't initialized in state
                    const delayModal = new bootstrap.Modal(document.getElementById('delayAlertModal'));
                    delayModal.show();
                }
            } catch (error) {
                console.error('Error showing delay modal:', error);
            }
        }

        // Utility Functions
        function getStatusClass(status, delayLevel = 0) {
            const classes = {
                preparing: 'bg-info',
                pending: 'bg-warning',
                delivered: 'bg-primary',
                'paid(online)': 'bg-success',
                'paid (cash)': 'bg-success'
            };
            return classes[status] || 'bg-secondary';
        }

        function highlightSearchMatch(text, searchQuery) {
            if (!searchQuery || !text) return text;

            searchQuery = searchQuery.toLowerCase().trim();
            if (!searchQuery) return text;

            // Escape special characters in the search query for use in regex
            const escapedQuery = searchQuery.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

            // Create a regex to find the search query in the text (case insensitive)
            const regex = new RegExp(`(${escapedQuery})`, 'gi');

            // Replace matches with highlighted spans
            return text.replace(regex, '<span class="search-highlight">$1</span>');
        }

        function getDelayColor(order) {
            // Clamp delayLevel between 0 and 5 for color mapping
            const delayLevel = Math.min(Math.max(order.delayLevel || 0, 0), 5);
            // Map delayLevel 0 (green) to 5 (dark red)
            const hue = 120 - (delayLevel * 24); // 120 to 0 hue range
            return `hsl(${hue}, 80%, 50%)`;
        }

        function formatTime(date) {
            return date.toLocaleTimeString('en-IN', { hour: '2-digit', minute: '2-digit' });
        }

        function formatElapsedTime(date) {
            if (!date) return "Unknown";

            const now = new Date();
            const elapsedMs = now - date;
            const totalMinutes = Math.floor(elapsedMs / 60000);

            if (totalMinutes < 60) {
                return `${totalMinutes} min ago`;
            } else {
                const hours = Math.floor(totalMinutes / 60);
                const minutes = totalMinutes % 60;
                return `${hours}h ${minutes}m ago`;
            }
        }

        // Delay comparison functions
        function debugDelayComparison() {
            console.log("Debug delay comparison");
            console.log("Current orders:", state.currentOrders);

            // Check orders by status
            const preparingOrders = state.currentOrders.filter(order => order.status === 'preparing');
            const pendingOrders = state.currentOrders.filter(order => order.status === 'pending');
            const deliveredOrders = state.currentOrders.filter(order => order.status === 'delivered');

            console.log("Orders with 'preparing' status:", preparingOrders);
            console.log("Orders with 'pending' status:", pendingOrders);
            console.log("Orders with 'delivered' status:", deliveredOrders);

            // Show delay information for each order
            state.currentOrders.forEach(order => {
                const delayInfo = calculateExactDelay(order);
                console.log(`Order ${order.docId} - Status: ${order.status}, Delay Level: ${delayInfo.delayLevel}, Delay Minutes: ${delayInfo.delayMinutes}`);
            });

            // Force show the comparison
            const container = document.getElementById('delayComparisonContainer');
            container.style.display = 'block';
            showDelayComparison();
        }

        function debugKitchenList() {
            console.log("Debug kitchen list");

            // Check orders with items
            const ordersWithItems = state.currentOrders.filter(order =>
                order.items && Array.isArray(order.items) && order.items.length > 0
            );

            console.log("Orders with items:", ordersWithItems);

            // Check orders that should be in kitchen list
            const kitchenOrders = state.currentOrders.filter(order =>
                (order.status === 'preparing' || order.status === 'pending') &&
                order.items && Array.isArray(order.items) && order.items.length > 0
            );

            console.log("Orders that should be in kitchen list:", kitchenOrders);

            // Check each order's items
            kitchenOrders.forEach(order => {
                console.log(`Order ${order.docId} - Status: ${order.status}, Items:`, order.items);
            });

            // Force refresh the kitchen list
            renderKitchenList();
        }

        function toggleDelayComparison() {
            console.log("Toggle delay comparison clicked");
            const container = document.getElementById('delayComparisonContainer');

            // Check the computed style instead of the inline style
            const displayStyle = window.getComputedStyle(container).display;
            console.log("Current display style:", displayStyle);

            if (displayStyle === 'none') {
                container.style.display = 'block';
                console.log("Showing delay comparison");
                // Force refresh of the delay comparison table
                setTimeout(() => {
                    showDelayComparison();
                }, 100);
            } else {
                container.style.display = 'none';
                console.log("Hiding delay comparison");
            }
        }

        function showDelayComparison() {
            const tableContainer = document.getElementById('delayComparisonTable');

            console.log("Current orders:", state.currentOrders);

            // Sort orders by delay time (descending)
            const filteredOrders = [...state.currentOrders].filter(order => {
                console.log(`Order ${order.docId} - status: ${order.status}, createdAt: ${order.createdAt}`);
                // Include both 'preparing' and 'pending' orders
                return order.createdAt && (order.status === 'preparing' || order.status === 'pending');
            });

            console.log("Filtered orders:", filteredOrders);

            const sortedOrders = filteredOrders
                .map(order => {
                    const delayInfo = calculateExactDelay(order);
                    return { ...order, delayInfo };
                })
                .sort((a, b) => b.delayInfo.totalMinutes - a.delayInfo.totalMinutes);

            if (sortedOrders.length === 0) {
                tableContainer.innerHTML = '<p class="text-center">No active orders to compare.</p>';
                return;
            }

            // Create the comparison table
            let tableHTML = `
                <div class="table-responsive">
                    <table class="table table-striped table-hover">
                        <thead class="table-dark">
                            <tr>
                                <th style="min-width: 150px;"><i class="bi bi-chat-left-text"></i> Comment</th>
                                <th><i class="bi bi-flag"></i> Status</th>
                                <th><i class="bi bi-calendar-check"></i> Order Time</th>
                                <th><i class="bi bi-hourglass-split"></i> Time Since</th>
                                <th><i class="bi bi-stopwatch"></i> Expected</th>
                                <th><i class="bi bi-graph-up-arrow"></i> Delay</th>
                                <th><i class="bi bi-thermometer-half"></i> Level</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            sortedOrders.forEach(order => {
                const { totalMinutes, hours, minutes, expectedMinutes, delayMinutes, delayLevel } = order.delayInfo;
                const delayClass = delayLevel > 0 ? 'text-danger' : 'text-success';
                const delayText = delayLevel > 0 ? `+${delayMinutes} min` : 'On time';

                tableHTML += `
                    <tr class="${delayLevel > 2 ? 'table-danger' : delayLevel > 0 ? 'table-warning' : ''} delay-comparison-row" 
                        data-order-id="${order.docId}" 
                        data-delay-level="${delayLevel}"
                        style="cursor: pointer;"
                        title="Click to highlight this order">
                        <td title="Order #${(order.id ? order.id.toString() : order.docId).slice(-4)} - ${order.customerDetails && order.customerDetails.comments ? order.customerDetails.comments : 'No comment'}" style="max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                            ${order.customerDetails && order.customerDetails.comments ? order.customerDetails.comments : '<em class="text-muted">No comment</em>'}
                        </td>
                        <td><span class="badge ${getStatusClass(order.status)}">${order.status}</span></td>
                        <td>${formatTime(order.createdAt)}</td>
                        <td><strong>${hours > 0 ? `${hours}h ${minutes}m` : `${totalMinutes}m`}</strong></td>
                        <td>${expectedMinutes}m</td>
                        <td class="${delayClass}"><strong>${delayText}</strong></td>
                        <td>
                            <div class="badge delay-level-${Math.min(delayLevel, 5)}">${delayLevel}</div>
                        </td>
                    </tr>
                `;
            });

            tableHTML += `
                        </tbody>
                    </table>
                </div>
            `;

            // Add summary statistics
            const delayedOrders = sortedOrders.filter(order => order.delayInfo.delayLevel > 0);
            const criticalOrders = sortedOrders.filter(order => order.delayInfo.delayLevel > 2);

            if (sortedOrders.length > 0) {
                tableHTML += `
                <div class="alert ${criticalOrders.length > 0 ? 'alert-danger' : delayedOrders.length > 0 ? 'alert-warning' : 'alert-success'} mt-3">
                    <h6 class="mb-2"><i class="bi bi-info-circle"></i> Summary</h6>
                    <div class="d-flex justify-content-between">
                        <span><strong>Total Orders:</strong> ${sortedOrders.length}</span>
                        <span><strong>Delayed Orders:</strong> ${delayedOrders.length} (${Math.round(delayedOrders.length / sortedOrders.length * 100)}%)</span>
                        <span><strong>Critical Delays:</strong> ${criticalOrders.length} (${Math.round(criticalOrders.length / sortedOrders.length * 100)}%)</span>
                    </div>
                </div>
                `;
            }

            tableContainer.innerHTML = tableHTML;

            // Add event listeners to the delay comparison rows
            setTimeout(() => {
                document.querySelectorAll('.delay-comparison-row').forEach(row => {
                    row.addEventListener('click', handleDelayComparisonRowClick);
                });
            }, 100);
        }

        function calculateExactDelay(order) {
            console.log(`Calculating delay for order ${order.docId} with status ${order.status}`);

            const statusDurations = {
                preparing: 25,
                pending: 15,
                delivered: 0,
                'paid(online)': 0,
                'paid (cash)': 0
            };

            // Calculate elapsed time since order creation
            const now = new Date();
            const createdAt = order.createdAt || now;
            console.log(`Order ${order.docId} createdAt:`, createdAt);

            const elapsedMs = now - createdAt;
            const totalMinutes = Math.floor(elapsedMs / 60000);
            const hours = Math.floor(totalMinutes / 60);
            const minutes = totalMinutes % 60;

            console.log(`Order ${order.docId} elapsed time: ${totalMinutes} minutes (${hours}h ${minutes}m)`);

            // Calculate expected time based on status
            const expectedMinutes = statusDurations[order.status] || 15;
            console.log(`Order ${order.docId} expected time: ${expectedMinutes} minutes`);

            // Calculate delay
            const delayMinutes = Math.max(0, totalMinutes - expectedMinutes);
            const delayLevel = delayMinutes > 0 ? Math.floor(delayMinutes / 5) + 1 : 0;
            console.log(`Order ${order.docId} delay: ${delayMinutes} minutes, level: ${delayLevel}`);

            return {
                totalMinutes,
                hours,
                minutes,
                expectedMinutes,
                delayMinutes,
                delayLevel
            };

            return {
                totalMinutes,
                hours,
                minutes,
                expectedMinutes,
                delayMinutes,
                delayLevel
            };
        }

        // Order Modification Functions
        function createEditOrderItemRow(item) {
            const editOrderItemsContainer = document.getElementById('editOrderItemsContainer');
            const row = document.createElement('div');
            row.className = 'd-flex gap-2 mb-2 align-items-center';

            const itemSelect = document.createElement('select');
            itemSelect.className = 'form-select flex-grow-1';
            itemSelect.required = true;

            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Select Item';
            defaultOption.disabled = true;
            defaultOption.selected = true;
            itemSelect.appendChild(defaultOption);

            for (const [id, menuItem] of Object.entries(state.menuItems)) {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = menuItem.name;
                if (item && item.id == id) {
                    option.selected = true;
                }
                itemSelect.appendChild(option);
            }

            const portionSelect = document.createElement('select');
            portionSelect.className = 'form-select';
            portionSelect.required = true;
            portionSelect.style.width = '120px';

            const quantityInput = document.createElement('input');
            quantityInput.type = 'number';
            quantityInput.min = '1';
            quantityInput.value = item ? item.quantity : 1;
            quantityInput.className = 'form-control';
            quantityInput.style.width = '80px';
            quantityInput.required = true;

            const priceDisplay = document.createElement('div');
            priceDisplay.style.minWidth = '80px';
            priceDisplay.textContent = '₹0';

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'btn btn-danger btn-sm';
            removeBtn.textContent = 'Remove';

            row.appendChild(itemSelect);
            row.appendChild(portionSelect);
            row.appendChild(quantityInput);
            row.appendChild(priceDisplay);
            row.appendChild(removeBtn);

            function updatePortions() {
                const itemId = itemSelect.value;
                portionSelect.innerHTML = '';
                if (itemId && state.menuItems[itemId]) {
                    const portions = state.menuItems[itemId].portions;
                    for (const [key, portion] of Object.entries(portions)) {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = `${portion.name} - ₹${portion.price}`;
                        if (item && item.portion === portion.name) {
                            option.selected = true;
                        }
                        portionSelect.appendChild(option);
                    }
                }
                updatePrice();
            }

            function updatePrice() {
                const itemId = itemSelect.value;
                const portionKey = portionSelect.value;
                const quantity = parseInt(quantityInput.value) || 0;
                if (itemId && portionKey && state.menuItems[itemId]) {
                    const price = state.menuItems[itemId].portions[portionKey].price * quantity;
                    priceDisplay.textContent = `₹${price}`;
                } else {
                    priceDisplay.textContent = '₹0';
                }
                updateTotal();
            }

            function updateTotal() {
                let total = 0;
                const rows = editOrderItemsContainer.querySelectorAll('div.d-flex');
                rows.forEach(r => {
                    const priceText = r.querySelector('div').textContent;
                    const price = parseInt(priceText.replace('₹', '')) || 0;
                    total += price;
                });
                document.getElementById('editOrderTotal').textContent = total;
            }

            itemSelect.addEventListener('change', () => {
                updatePortions();
            });

            portionSelect.addEventListener('change', () => {
                updatePrice();
            });

            quantityInput.addEventListener('input', () => {
                updatePrice();
            });

            removeBtn.addEventListener('click', () => {
                row.remove();
                updateTotal();
            });

            updatePortions();

            return row;
        }

        async function showEditModal(docId) {
            const order = state.currentOrders.find(o => o.docId === docId);
            state.editingOrderId = docId;

            // Populate edit form with order details
            document.getElementById('editCustomerPhone').value = order.customerDetails.phone || '';
            document.getElementById('editCustomerComments').value = order.customerDetails.comments || '';

            const editOrderItemsContainer = document.getElementById('editOrderItemsContainer');
            editOrderItemsContainer.innerHTML = '';

            if (order.items && order.items.length > 0) {
                order.items.forEach(item => {
                    const row = createEditOrderItemRow(item);
                    editOrderItemsContainer.appendChild(row);
                });
            } else {
                const row = createEditOrderItemRow();
                editOrderItemsContainer.appendChild(row);
            }

            document.getElementById('editOrderTotal').textContent = order.total || 0;

            state.modals.editOrder.show();
        }

        async function handleOrderEdit(e) {
            e.preventDefault();

            const phone = document.getElementById('editCustomerPhone').value.trim();
            const comments = document.getElementById('editCustomerComments').value.trim();

            // Phone validation removed - now optional

            const items = [];
            const editOrderItemsContainer = document.getElementById('editOrderItemsContainer');
            const rows = editOrderItemsContainer.querySelectorAll('div.d-flex');

            if (rows.length === 0) {
                alert('Please add at least one order item.');
                return;
            }

            for (const row of rows) {
                const itemSelect = row.querySelector('select.form-select');
                const portionSelect = row.querySelectorAll('select.form-select')[1];
                const quantityInput = row.querySelector('input[type="number"]');
                const itemId = itemSelect.value;
                const portionKey = portionSelect.value;
                const quantity = parseInt(quantityInput.value);

                if (!itemId || !portionKey || !quantity || quantity <= 0) {
                    alert('Please fill all item details correctly.');
                    return;
                }

                const itemData = state.menuItems[itemId];
                const portionData = itemData.portions[portionKey];

                items.push({
                    id: itemId,
                    name: itemData.name,
                    portion: portionData.name,
                    quantity,
                    price: portionData.price
                });
            }

            const total = items.reduce((sum, i) => sum + i.price * i.quantity, 0);

            try {
                await db.collection('bot_orders').doc(state.editingOrderId).update({
                    customerDetails: { phone, comments },
                    items,
                    total,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                alert('Order updated successfully.');
                state.modals.editOrder.hide();
            } catch (error) {
                alert('Error updating order: ' + error.message);
            }
        }

        // Existing Functions with Optimizations
        async function deleteOrder(docId) {
            if (confirm('Confirm deletion?')) await db.collection('bot_orders').doc(docId).delete();
        }

        async function updateOrderStatus(docId, newStatus) {
            try {
                console.log(`Updating order ${docId} status to ${newStatus}...`);
                await db.collection('bot_orders').doc(docId).update({
                    status: newStatus,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                console.log(`Order ${docId} status updated to ${newStatus}`);

                // Clear alert for this order if it's no longer active
                if (!['pending', 'preparing'].includes(newStatus)) {
                    console.log(`Clearing alert for order ${docId} as it's now ${newStatus}`);
                    state.alertedOrders.delete(docId);

                    // If this was the current delay order, close the modal
                    if (state.currentDelayOrder && state.currentDelayOrder.docId === docId) {
                        console.log(`Closing delay alert modal for order ${docId}`);
                        state.currentDelayOrder = null;
                        const delayAlertModal = bootstrap.Modal.getInstance(document.getElementById('delayAlertModal'));
                        if (delayAlertModal) {
                            delayAlertModal.hide();
                        }
                    }
                }

                // Refresh UI and check delays after status update
                loadOrders();
            } catch (error) {
                alert('Error updating order status: ' + error.message);
            }
        }

        async function sendDelayMessage() {
            const order = state.currentDelayOrder;
            const orderIdStr = order.id ? order.id.toString() : order.docId;
            const message = `Your order #${orderIdStr.slice(-4)} is delayed. New ETA: ${calculateNewETA(order)}`;
            window.open(`https://wa.me/${order.customerDetails.phone}?text=${encodeURIComponent(message)}`, '_blank');

            // Close the modal and move focus to a safe element
            const delayAlertModal = document.getElementById('delayAlertModal');
            const refreshButton = document.querySelector('button.btn-primary[onclick="loadOrders()"]');

            // First hide the modal
            state.modals.delay.hide();

            // Then set focus to the refresh button after the modal is fully hidden
            delayAlertModal.addEventListener('hidden.bs.modal', function onHidden() {
                if (refreshButton) refreshButton.focus();
                // Remove the event listener after it's executed once
                delayAlertModal.removeEventListener('hidden.bs.modal', onHidden);
            }, { once: true });
        }

        function calculateNewETA(order) {
            const buffer = (order.delayLevel * 5) + 10;
            return new Date(Date.now() + buffer * 60000).toLocaleTimeString('en-IN', { hour: '2-digit', minute: '2-digit' });
        }

        // Add remaining functions from previous versions with similar optimizations

        function saveVehicleNumber() {
            // TODO: Implement save vehicle number logic
            console.log('saveVehicleNumber called');

            // Close the modal and move focus to a safe element
            const vehicleModal = document.getElementById('vehicleModal');
            const refreshButton = document.querySelector('button.btn-primary[onclick="loadOrders()"]');

            // First hide the modal
            state.modals.vehicle.hide();

            // Then set focus to the refresh button after the modal is fully hidden
            vehicleModal.addEventListener('hidden.bs.modal', function onHidden() {
                if (refreshButton) refreshButton.focus();
                // Remove the event listener after it's executed once
                vehicleModal.removeEventListener('hidden.bs.modal', onHidden);
            }, { once: true });
        }

        async function handleNewOrder(e) {
            e.preventDefault();

            // Get form data
            const phone = document.getElementById('customerPhone').value.trim();
            const comments = document.getElementById('customerComments').value.trim();

            // Phone validation removed - now optional

            // Get order items
            const items = [];
            const orderItemsContainer = document.getElementById('orderItemsContainer');
            const orderTotalElem = document.getElementById('orderTotal');
            const rows = orderItemsContainer.querySelectorAll('div.d-flex');

            // Validate at least one item
            if (rows.length === 0) {
                alert('Please add at least one order item.');
                return;
            }

            // Process each item
            for (const row of rows) {
                const itemSelect = row.querySelector('select.form-select');
                const portionSelect = row.querySelectorAll('select.form-select')[1];
                const quantityInput = row.querySelector('input[type="number"]');
                const itemId = itemSelect.value;
                const portionKey = portionSelect.value;
                const quantity = parseInt(quantityInput.value);

                // Validate item details
                if (!itemId || !portionKey || !quantity || quantity <= 0) {
                    alert('Please fill all item details correctly.');
                    return;
                }

                const itemData = state.menuItems[itemId];
                const portionData = itemData.portions[portionKey];
                items.push({
                    id: itemId,
                    name: itemData.name,
                    portion: portionData.name,
                    quantity,
                    price: portionData.price
                });
            }

            // Calculate total
            const total = items.reduce((sum, i) => sum + i.price * i.quantity, 0);

            try {
                // First close the modal before the async operation
                // This ensures UI is not blocked during the database operation
                const modal = bootstrap.Modal.getInstance(document.getElementById('addOrderModal'));
                if (modal) {
                    modal.hide();
                }

                // Clean up any modal artifacts
                const modalBackdrops = document.querySelectorAll('.modal-backdrop');
                modalBackdrops.forEach(backdrop => {
                    backdrop.parentNode.removeChild(backdrop);
                });
                document.body.classList.remove('modal-open');
                document.body.style.removeProperty('padding-right');
                document.body.style.removeProperty('overflow');

                // Add order to database
                await db.collection('bot_orders').add({
                    customerDetails: { phone, comments },
                    items,
                    total,
                    status: 'pending',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });

                // Reset form
                e.target.reset();
                orderItemsContainer.innerHTML = '';
                orderTotalElem.textContent = '0';

                // Show success message
                alert('Order added successfully.');

                // Refresh orders list
                loadOrders();

            } catch (error) {
                alert('Error adding order: ' + error.message);
            }
        }

        async function handleOrderEdit(e) {
            e.preventDefault();

            const phone = document.getElementById('editCustomerPhone').value.trim();
            const comments = document.getElementById('editCustomerComments').value.trim();
            // Phone validation removed - now optional
            const items = [];
            const orderItemsContainer = document.getElementById('editOrderItemsContainer');
            const orderTotalElem = document.getElementById('editOrderTotal');
            const rows = orderItemsContainer.querySelectorAll('div.d-flex');
            if (rows.length === 0) {
                alert('Please add at least one order item.');
                return;
            }
            for (const row of rows) {
                const itemSelect = row.querySelector('select.form-select');
                const portionSelect = row.querySelectorAll('select.form-select')[1];
                const quantityInput = row.querySelector('input[type="number"]');
                const itemId = itemSelect.value;
                const portionKey = portionSelect.value;
                const quantity = parseInt(quantityInput.value);
                if (!itemId || !portionKey || !quantity || quantity <= 0) {
                    alert('Please fill all item details correctly.');
                    return;
                }
                const itemData = state.menuItems[itemId];
                const portionData = itemData.portions[portionKey];
                items.push({
                    id: itemId,
                    name: itemData.name,
                    portion: portionData.name,
                    quantity,
                    price: portionData.price
                });
            }
            const total = items.reduce((sum, i) => sum + i.price * i.quantity, 0);
            try {
                await db.collection('bot_orders').doc(state.editingOrderId).update({
                    customerDetails: { phone, comments },
                    items,
                    total,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                alert('Order updated successfully.');
                e.target.reset();
                orderItemsContainer.innerHTML = '';
                orderTotalElem.textContent = '0';

                // Close the modal and move focus to a safe element
                const editOrderModal = document.getElementById('editOrderModal');
                const refreshButton = document.querySelector('button.btn-primary[onclick="loadOrders()"]');

                // First hide the modal
                state.modals.editOrder.hide();

                // Then set focus to the refresh button after the modal is fully hidden
                editOrderModal.addEventListener('hidden.bs.modal', function onHidden() {
                    if (refreshButton) refreshButton.focus();
                    // Remove the event listener after it's executed once
                    editOrderModal.removeEventListener('hidden.bs.modal', onHidden);
                }, { once: true });
            } catch (error) {
                alert('Error updating order: ' + error.message);
            }
        }

        // Add order form handling
        document.addEventListener('DOMContentLoaded', () => {
            const addOrderItemBtn = document.getElementById('addOrderItemBtn');
            const orderItemsContainer = document.getElementById('orderItemsContainer');
            const orderTotalElem = document.getElementById('orderTotal');
            const addOrderForm = document.getElementById('addOrderForm');

            // Search functionality
            const searchInput = document.getElementById('orderSearchInput');
            const clearSearchBtn = document.getElementById('clearSearchBtn');

            // Initialize search results count
            document.getElementById('searchResultsCount').textContent = state.currentOrders.length;

            // Add event listener for search input
            searchInput.addEventListener('input', (e) => {
                const query = e.target.value;
                searchOrders(query);
                renderOrders();
            });

            // Add event listener for clear button
            clearSearchBtn.addEventListener('click', () => {
                searchInput.value = '';
                searchOrders('');
                renderOrders();
            });

            // Add keyboard shortcut (Ctrl+F or Cmd+F) to focus the search input
            document.addEventListener('keydown', (e) => {
                // Check if Ctrl+F or Cmd+F is pressed
                if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                    // Prevent the default browser search
                    e.preventDefault();
                    // Focus the search input
                    searchInput.focus();
                }
            });

            function createOrderItemRow() {
                const row = document.createElement('div');
                row.className = 'd-flex gap-2 mb-2 align-items-center';

                const itemSelect = document.createElement('select');
                itemSelect.className = 'form-select flex-grow-1';
                itemSelect.required = true;

                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = 'Select Item';
                defaultOption.disabled = true;
                defaultOption.selected = true;
                itemSelect.appendChild(defaultOption);

                for (const [id, item] of Object.entries(state.menuItems)) {
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = item.name;
                    itemSelect.appendChild(option);
                }

                const portionSelect = document.createElement('select');
                portionSelect.className = 'form-select';
                portionSelect.required = true;
                portionSelect.style.width = '120px';

                const quantityInput = document.createElement('input');
                quantityInput.type = 'number';
                quantityInput.min = '1';
                quantityInput.value = '1';
                quantityInput.className = 'form-control';
                quantityInput.style.width = '80px';
                quantityInput.required = true;

                const priceDisplay = document.createElement('div');
                priceDisplay.style.minWidth = '80px';
                priceDisplay.textContent = '₹0';

                const removeBtn = document.createElement('button');
                removeBtn.type = 'button';
                removeBtn.className = 'btn btn-danger btn-sm';
                removeBtn.textContent = 'Remove';

                row.appendChild(itemSelect);
                row.appendChild(portionSelect);
                row.appendChild(quantityInput);
                row.appendChild(priceDisplay);
                row.appendChild(removeBtn);

                function updatePortions() {
                    const itemId = itemSelect.value;
                    portionSelect.innerHTML = '';
                    if (itemId && state.menuItems[itemId]) {
                        const portions = state.menuItems[itemId].portions;
                        for (const [key, portion] of Object.entries(portions)) {
                            const option = document.createElement('option');
                            option.value = key;
                            option.textContent = `${portion.name} - ₹${portion.price}`;
                            portionSelect.appendChild(option);
                        }
                    }
                    updatePrice();
                }

                function updatePrice() {
                    const itemId = itemSelect.value;
                    const portionKey = portionSelect.value;
                    const quantity = parseInt(quantityInput.value) || 0;
                    if (itemId && portionKey && state.menuItems[itemId]) {
                        const price = state.menuItems[itemId].portions[portionKey].price * quantity;
                        priceDisplay.textContent = `₹${price}`;
                    } else {
                        priceDisplay.textContent = '₹0';
                    }
                    updateTotal();
                }

                function updateTotal() {
                    let total = 0;
                    const rows = orderItemsContainer.querySelectorAll('div.d-flex');
                    rows.forEach(r => {
                        const priceText = r.querySelector('div').textContent;
                        const price = parseInt(priceText.replace('₹', '')) || 0;
                        total += price;
                    });
                    orderTotalElem.textContent = total;
                }

                itemSelect.addEventListener('change', () => {
                    updatePortions();
                });

                portionSelect.addEventListener('change', () => {
                    updatePrice();
                });

                quantityInput.addEventListener('input', () => {
                    updatePrice();
                });

                removeBtn.addEventListener('click', () => {
                    row.remove();
                    updateTotal();
                });

                return row;
            }

            addOrderItemBtn.addEventListener('click', () => {
                const row = createOrderItemRow();
                orderItemsContainer.appendChild(row);
            });

        });
    </script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
</body>

</html>