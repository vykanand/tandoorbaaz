<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tandoorbaaz Expense Tracker - BK, Rachit, Vikas, Tandoorbaaz</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }

        h1,
        h2,
        h3 {
            color: #2c3e50;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .form-section,
        .summary-section {
            flex: 1;
            min-width: 300px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        input[type="text"],
        input[type="number"],
        select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }

        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
            margin-bottom: 5px;
        }

        button:hover {
            background-color: #45a049;
        }

        button.secondary {
            background-color: #3498db;
        }

        button.secondary:hover {
            background-color: #2980b9;
        }

        button.danger {
            background-color: #e74c3c;
        }

        button.danger:hover {
            background-color: #c0392b;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        th {
            background-color: #f2f2f2;
        }

        tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }

        .checkbox-item input {
            margin-right: 5px;
        }

        .positive {
            color: green;
        }

        .negative {
            color: red;
        }

        .status-message {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            display: none;
        }

        .status-message.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-message.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .loading-spinner {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 2s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .tabs {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 20px;
        }

        .tab {
            padding: 10px 15px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            margin-right: 5px;
            border-radius: 4px 4px 0 0;
        }

        .tab.active {
            background-color: #f9f9f9;
            border-color: #ddd;
            border-bottom: 1px solid #f9f9f9;
            margin-bottom: -1px;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Pagination styles */
        .pagination-controls {
            display: flex;
            align-items: center;
            margin: 20px 0;
            gap: 10px;
        }

        #pageInfo {
            margin: 0 10px;
        }

        /* Transaction filters */
        .transaction-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 15px;
        }

        .transaction-filters .form-group {
            flex: 1;
            min-width: 200px;
        }

        /* Quick summary */
        #quickSummary {
            padding: 10px;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .summary-item {
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
        }

        .summary-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        /* Summary tables */
        .summary-table {
            width: 100%;
            margin-top: 15px;
        }

        .summary-table th, 
        .summary-table td {
            text-align: center;
        }

        .summary-table th:first-child,
        .summary-table td:first-child {
            text-align: left;
        }

        .summary-section h3 {
            margin-top: 25px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        
        /* Worker detail styles */
        #workerDetailSection {
            margin-top: 30px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 5px;
            border: 1px solid #eee;
        }
        
        #workerDetailTitle {
            margin-top: 0;
            color: #2c3e50;
        }
    </style>
    <!-- Firebase Scripts -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
</head>

<body>
    <h1>Tandoorbaaz Expense Tracker</h1>
    <div id="statusMessage" class="status-message"></div>

    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
    </div>

    <div class="tabs">
        <div class="tab active" data-tab="payments">Vendor and Salary Payments</div>
        <div class="tab" data-tab="summary">Payment Summary</div>
    </div>

    <div id="paymentsTab" class="tab-content active">
        <div class="container">
            <div class="form-section">
                <h2>Add New Salary Payment</h2>
                <div class="form-group">
                    <label for="employer">Paid by (Employer):</label>
                    <select id="employer"></select>
                </div>
                <div class="form-group">
                    <label for="worker">Paid to (Worker):</label>
                    <select id="worker"></select>
                </div>
                <div class="form-group">
                    <label for="amount">Amount (â‚¹):</label>
                    <input type="number" id="amount" min="0" step="0.01" placeholder="Enter amount">
                </div>
                <div class="form-group">
                    <label for="purpose">Purpose:</label>
                    <input type="text" id="purpose" placeholder="What was this payment for?">
                </div>
                <button onclick="addSalaryPayment()">Add Payment</button>
                <button class="secondary" onclick="refreshPayments()">Refresh Data</button>
            </div>

            <div class="summary-section">
                <h2>Quick Summary</h2>
                <div id="quickSummary"></div>
            </div>
        </div>

        <h2>Vendor and Salary Payments</h2>
        <div class="transaction-filters">
            <div class="form-group">
                <label for="paymentSearch">Search:</label>
                <input type="text" id="paymentSearch" placeholder="Search by purpose, employer or worker">
            </div>
            <div class="form-group">
                <label for="paymentDateFilter">Date Range:</label>
                <select id="paymentDateFilter">
                    <option value="all">All Time</option>
                    <option value="today">Today</option>
                    <option value="week">This Week</option>
                    <option value="month">This Month</option>
                    <option value="custom">Custom Range</option>
                </select>
            </div>
        </div>

        <table>
            <thead>
                <tr>
                    <th>Date</th>
                    <th>Employer</th>
                    <th>Worker</th>
                    <th>Amount</th>
                    <th>Purpose</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody id="paymentsList"></tbody>
        </table>

        <div class="pagination-controls">
            <button id="prevPage" class="secondary" onclick="changePage(-1)">Previous</button>
            <span id="pageInfo">Page 1 of 1</span>
            <button id="nextPage" class="secondary" onclick="changePage(1)">Next</button>
            <select id="pageSize" onchange="changePageSize()">
                <option value="10">10 per page</option>
                <option value="25">25 per page</option>
                <option value="50">50 per page</option>
                <option value="100">100 per page</option>
            </select>
        </div>

        <button class="danger" onclick="clearAllTransactions()">Clear All Vendor and Salary Payments</button>
    </div>

    <div id="summaryTab" class="tab-content">
        <h2>Payment Summary</h2>
        <p>Overview of salary payments by employers and to workers.</p>

        <div class="container">
            <div class="summary-section">
                <h3>Employer Payments</h3>
                <p>Total amount paid by each employer:</p>
                <table class="summary-table">
                    <thead>
                        <tr>
                            <th>Employer</th>
                            <th>Total Paid</th>
                        </tr>
                    </thead>
                    <tbody id="employerSummaryBody">
                        <!-- Employer summary rows will be added here -->
                    </tbody>
                </table>
            </div>

            <div class="summary-section">
                <h3>Vendor and Salary Payments</h3>
                <p>Total amount received by each vendor/worker:</p>
                <table class="summary-table">
                    <thead>
                        <tr>
                            <th>Vendor/Worker</th>
                            <th>Total Received</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="workerSummaryBody">
                        <!-- Worker summary rows will be added here -->
                    </tbody>
                </table>
            </div>
            
            <div class="summary-section" id="workerDetailSection" style="display: none;">
                <h3 id="workerDetailTitle">Expense Breakup</h3>
                <button class="secondary" onclick="hideWorkerDetail()">Back to Summary</button>
                <table class="summary-table">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Employer</th>
                            <th>Amount</th>
                            <th>Purpose</th>
                        </tr>
                    </thead>
                    <tbody id="workerDetailBody">
                        <!-- Worker detail rows will be added here -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <div id="settlementsTab" class="tab-content">
        <h2>Settlements</h2>
        <p>View who owes whom and settle up expenses.</p>

        <div class="container">
            <div class="form-section">
                <h3>Individual Balances</h3>
                <div id="balances"></div>
            </div>

            <div class="summary-section">
                <h3>Suggested Settlements</h3>
                <div id="settlements"></div>
            </div>
        </div>


    </div>

    <div id="peopleTab" class="tab-content">
        <h2>Manage People</h2>
        <p>Add or remove people from the expense tracker. <strong>Note:</strong> Removing a person will not remove their
            transactions.</p>

        <div class="form-group">
            <label for="newPersonName">Add New Person:</label>
            <div style="display: flex; gap: 10px;">
                <input type="text" id="newPersonName" placeholder="Enter name">
                <button onclick="addPerson()">Add Person</button>
            </div>
        </div>

        <h3>Current People</h3>
        <div class="people-list" id="peopleList"></div>
    </div>

    <div id="settingsTab" class="tab-content">
        <h2>Settings</h2>

        <div class="form-group">
            <h3>Firebase Configuration</h3>
            <p>This application is using Firebase for data storage. The Firebase configuration is set up in the code.</p>
            <p>Firebase Project: billion1-a9324</p>
        </div>

        <div class="form-group">
            <h3>Employers and Workers</h3>
            <p>The list of employers and workers is currently hardcoded in the application.</p>
            <p>Employers: BK, Rachit, Vikas, Tandoorbaaz</p>
            <p>Workers: Daksh, Nishu, Sumit, Prashant, Paneer Butter, Chicken Afzal, Tandoorbaaz Expense</p>
        </div>
    </div>

    <script>
        // Firebase Configuration and Initialization
        const firebaseConfig = {
            apiKey: "AIzaSyAEKHWdRyzI8WyBeGeesjDrM-nEzOXCuNk",
            authDomain: "billion1-a9324.firebaseapp.com",
            projectId: "billion1-a9324",
            storageBucket: "billion1-a9324.appspot.com",
            messagingSenderId: "443716692865",
            appId: "1:443716692865:web:96813fe32a44f8342cd680",
            measurementId: "G-FE7NFHY5PG"
        };

        // Initialize Firebase
        const app = firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        
        // Collection reference for salary payments
        const salaryCollection = db.collection('salaryPayments');

        // Global variables
        const employers = ['Tandoorbaaz', 'BK', 'Rachit', 'Vikas'];
        const workers = ['Sumit', 'Daksh', 'Nishu', 'Prashant', 'Paneer Butter', 'Chicken Afzal', 'Tandoorbaaz Expense'];
        let salaryPayments = [];
        let people = [...employers, ...workers]; // Initialize people with employers and workers

        // Pagination state
        let currentPage = 1;
        let pageSize = 10;
        let totalPages = 1;

        // Save settings
        function saveSettings() {
            binId = document.getElementById('jsonBinId').value.trim();
            masterKey = document.getElementById('jsonBinKey').value.trim();
            
            // Save to localStorage
            localStorage.setItem('salaryTrackerSettings', JSON.stringify({
                binId: binId,
                masterKey: masterKey
            }));
            
            showStatusMessage('Settings saved successfully', 'success');
            
            // Reload data with new settings
            loadData();
        }
        
        // Load settings from localStorage
        function loadSettings() {
            const savedSettings = localStorage.getItem('salaryTrackerSettings');
            if (savedSettings) {
                const settings = JSON.parse(savedSettings);
                if (settings.binId) {
                    binId = settings.binId;
                    document.getElementById('jsonBinId').value = binId;
                }
                if (settings.masterKey) {
                    masterKey = settings.masterKey;
                    document.getElementById('jsonBinKey').value = masterKey;
                }
            }
        }
        
        // Test connection to JSONBin
        async function testConnection() {
            showLoading(true);
            
            try {
                // Get values from inputs
                const testBinId = document.getElementById('jsonBinId').value.trim();
                const testMasterKey = document.getElementById('jsonBinKey').value.trim();
                
                // Test the connection
                const response = await fetch(`${JSON_BIN_URL}/${testBinId}/latest`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Master-Key': testMasterKey
                    }
                });
                
                if (response.ok) {
                    showStatusMessage('Connection successful!', 'success');
                } else {
                    showStatusMessage(`Connection failed: ${response.status} ${response.statusText}`, 'error');
                }
            } catch (error) {
                console.error('Error testing connection:', error);
                showStatusMessage('Connection error: ' + error.message, 'error');
            } finally {
                showLoading(false);
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize UI
            initializeUI();
            
            // Load data
            loadData();
            
            // Set up tab navigation
            initTabs();
        });

        // Initialize UI elements
        function initializeUI() {
            // Populate employer dropdown
            const employerSelect = document.getElementById('employer');
            employerSelect.innerHTML = '';
            employers.forEach(employer => {
                const option = document.createElement('option');
                option.value = employer;
                option.textContent = employer;
                employerSelect.appendChild(option);
            });
            
            // Populate worker dropdown
            const workerSelect = document.getElementById('worker');
            workerSelect.innerHTML = '';
            workers.forEach(worker => {
                const option = document.createElement('option');
                option.value = worker;
                option.textContent = worker;
                workerSelect.appendChild(option);
            });
            
            // Set up search and filter event listeners
            const searchInput = document.getElementById('paymentSearch');
            if (searchInput) {
                searchInput.addEventListener('input', function() {
                    currentPage = 1;
                    filterAndDisplayPayments();
                });
            }
            
            const dateFilter = document.getElementById('paymentDateFilter');
            if (dateFilter) {
                dateFilter.addEventListener('change', function() {
                    currentPage = 1;
                    filterAndDisplayPayments();
                });
            }
            
            // Set default page size
            document.getElementById('pageSize').value = pageSize;
        }

        // Initialize tabs
        function initTabs() {
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');

            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    // Remove active class from all tabs and contents
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(c => c.classList.remove('active'));

                    // Add active class to clicked tab and corresponding content
                    tab.classList.add('active');
                    const tabName = tab.getAttribute('data-tab');
                    document.getElementById(`${tabName}Tab`).classList.add('active');

                    // Special handling for summary tab
                    if (tabName === 'summary') {
                        // Update summary tables
                        updateSummaryTables();
                    }
                });
            });
        }

        // Load data from Firebase
        async function loadData() {
            try {
                showLoading(true);
                
                try {
                    // Fetch salary payments from Firebase
                    const snapshot = await salaryCollection.get();
                    
                    if (!snapshot.empty) {
                        // Clear existing payments
                        salaryPayments = [];
                        
                        // Process each document
                        snapshot.forEach(doc => {
                            const payment = doc.data();
                            
                            // Add the document ID to the payment object
                            payment.id = doc.id;
                            
                            // Convert Firestore timestamp to JavaScript Date
                            if (payment.date && payment.date.toDate) {
                                payment.date = payment.date.toDate();
                            } else if (typeof payment.date === 'string') {
                                payment.date = new Date(payment.date);
                            }
                            
                            salaryPayments.push(payment);
                        });
                        
                        // Update UI
                        filterAndDisplayPayments();
                        updateQuickSummary();
                        updateSummaryTables();
                        
                        showStatusMessage('Data loaded successfully from Firebase', 'success');
                    } else {
                        console.log('No salary payments found in Firebase');
                        salaryPayments = [];
                        filterAndDisplayPayments();
                        updateQuickSummary();
                        updateSummaryTables();
                    }
                } catch (error) {
                    console.error('Error loading data from Firebase:', error);
                    showStatusMessage('Error loading data: ' + error.message, 'error');
                    salaryPayments = [];
                    filterAndDisplayPayments();
                    updateQuickSummary();
                } finally {
                    showLoading(false);
                }
            } catch (error) {
                console.error('Error loading data:', error);
                showStatusMessage('Error loading data: ' + error.message, 'error');
                salaryPayments = [];
                filterAndDisplayPayments();
                updateQuickSummary();
            }
        }
        
        // Load data from localStorage
        function loadFromLocalStorage() {
            try {
                const savedPayments = localStorage.getItem('salaryPayments');
                if (savedPayments) {
                    salaryPayments = JSON.parse(savedPayments);
                    
                    // Convert date strings back to Date objects for proper sorting
                    salaryPayments.forEach(payment => {
                        if (typeof payment.date === 'string') {
                            payment.date = new Date(payment.date);
                        }
                    });
                    
                    usingLocalStorage = true;
                    filterAndDisplayPayments();
                    updateQuickSummary();
                    showStatusMessage('Data loaded from local storage', 'success');
                } else {
                    salaryPayments = [];
                    filterAndDisplayPayments();
                    updateQuickSummary();
                }
            } catch (error) {
                console.error('Error loading from localStorage:', error);
                salaryPayments = [];
                filterAndDisplayPayments();
                updateQuickSummary();
            }
        }
        
        // Initialize data structure in JSONBin
        async function initializeData() {
            const initialData = {
                salaryPayments: []
            };
            
            try {
                const response = await fetch(`${JSON_BIN_URL}/${binId}`, {
                    method: 'PUT',
                    headers: getHeaders(),
                    body: JSON.stringify(initialData)
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to initialize data: ${response.status}`);
                }
                
                salaryPayments = [];
                filterAndDisplayPayments();
                updateQuickSummary();
                showStatusMessage('Data initialized successfully', 'success');
            } catch (error) {
                console.error('Error initializing data:', error);
                showStatusMessage('Error initializing data. Using local storage.', 'error');
                usingLocalStorage = true;
            }
        }

        // Save data to localStorage or JSONBin
        async function saveData() {
            // First save to localStorage as backup
            saveToLocalStorage();
            
            // If we're in localStorage mode, don't try to save to JSONBin
            if (usingLocalStorage) {
                return;
            }
            
            try {
                showLoading(true);
                
                const dataToSave = {
                    salaryPayments: salaryPayments
                };
                
                const response = await fetch(`${JSON_BIN_URL}/${binId}`, {
                    method: 'PUT',
                    headers: getHeaders(),
                    body: JSON.stringify(dataToSave)
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to save data: ${response.status}`);
                }
                
                showStatusMessage('Data saved successfully', 'success');
            } catch (error) {
                console.error('Error saving data:', error);
                showStatusMessage('Error saving data to server. Data saved locally.', 'error');
                usingLocalStorage = true;
            } finally {
                showLoading(false);
            }
        }
        
        // This function has been removed as we're now using Firebase instead of localStorage
        
        // This function has been removed as we're now using Firebase instead of JSONBin

        // Add a new salary payment
        async function addSalaryPayment() {
            const employer = document.getElementById('employer').value;
            const worker = document.getElementById('worker').value;
            const amount = parseFloat(document.getElementById('amount').value);
            const purpose = document.getElementById('purpose').value;
            
            // Validate inputs
            if (!employer || !worker) {
                showStatusMessage('Please select both employer and worker', 'error');
                return;
            }
            
            if (isNaN(amount) || amount <= 0) {
                showStatusMessage('Please enter a valid amount', 'error');
                return;
            }
            
            if (!purpose.trim()) {
                showStatusMessage('Please enter a purpose for the payment', 'error');
                return;
            }
            
            showLoading(true);
            
            try {
                // Create new payment object
                const newPayment = {
                    date: firebase.firestore.Timestamp.fromDate(new Date()),
                    employer: employer,
                    worker: worker,
                    amount: amount,
                    purpose: purpose,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };
                
                // Save to Firebase
                const docRef = await salaryCollection.add(newPayment);
                
                // Add the document ID and convert the Firestore timestamp to a Date
                newPayment.id = docRef.id;
                newPayment.date = newPayment.date.toDate();
                
                // Add to local array
                salaryPayments.push(newPayment);
                
                // Update UI
                filterAndDisplayPayments();
                updateQuickSummary();
                
                // Clear form
                document.getElementById('amount').value = '';
                document.getElementById('purpose').value = '';
                
                showStatusMessage('Salary payment added successfully to Firebase', 'success');
            } catch (error) {
                console.error('Error adding payment to Firebase:', error);
                showStatusMessage('Error adding payment: ' + error.message, 'error');
            } finally {
                showLoading(false);
            }
        }

        // Filter and display payments based on search and date filters
        function filterAndDisplayPayments() {
            const searchTerm = document.getElementById('paymentSearch')?.value?.toLowerCase() || '';
            const dateFilter = document.getElementById('paymentDateFilter')?.value || 'all';
            
            // Apply filters
            let filteredPayments = salaryPayments.filter(payment => {
                // Search filter
                const matchesSearch = 
                    payment.employer.toLowerCase().includes(searchTerm) ||
                    payment.worker.toLowerCase().includes(searchTerm) ||
                    payment.purpose.toLowerCase().includes(searchTerm);
                
                // Date filter
                let matchesDate = true;
                const paymentDate = new Date(payment.date);
                const today = new Date();
                
                if (dateFilter === 'today') {
                    matchesDate = 
                        paymentDate.getDate() === today.getDate() &&
                        paymentDate.getMonth() === today.getMonth() &&
                        paymentDate.getFullYear() === today.getFullYear();
                } else if (dateFilter === 'week') {
                    const oneWeekAgo = new Date();
                    oneWeekAgo.setDate(today.getDate() - 7);
                    matchesDate = paymentDate >= oneWeekAgo;
                } else if (dateFilter === 'month') {
                    const oneMonthAgo = new Date();
                    oneMonthAgo.setMonth(today.getMonth() - 1);
                    matchesDate = paymentDate >= oneMonthAgo;
                }
                
                return matchesSearch && matchesDate;
            });
            
            // Sort by date (newest first)
            filteredPayments.sort((a, b) => new Date(b.date) - new Date(a.date));
            
            // Pagination
            totalPages = Math.ceil(filteredPayments.length / pageSize) || 1;
            if (currentPage > totalPages) {
                currentPage = totalPages;
            }
            
            const startIndex = (currentPage - 1) * pageSize;
            const endIndex = startIndex + pageSize;
            const paymentsToDisplay = filteredPayments.slice(startIndex, endIndex);
            
            // Update page info
            const pageInfoElement = document.getElementById('pageInfo');
            if (pageInfoElement) {
                pageInfoElement.textContent = `Page ${currentPage} of ${totalPages}`;
            }
            
            // Enable/disable pagination buttons
            const prevPageButton = document.getElementById('prevPage');
            const nextPageButton = document.getElementById('nextPage');
            if (prevPageButton) prevPageButton.disabled = currentPage === 1;
            if (nextPageButton) nextPageButton.disabled = currentPage === totalPages;
            
            // Display payments
            const paymentsList = document.getElementById('paymentsList');
            if (!paymentsList) return;
            
            paymentsList.innerHTML = '';
            
            if (paymentsToDisplay.length === 0) {
                const row = document.createElement('tr');
                const cell = document.createElement('td');
                cell.colSpan = 6;
                cell.textContent = 'No salary payments found';
                cell.style.textAlign = 'center';
                row.appendChild(cell);
                paymentsList.appendChild(row);
                return;
            }
            
            paymentsToDisplay.forEach(payment => {
                const row = document.createElement('tr');
                
                // Format date
                const paymentDate = new Date(payment.date);
                const formattedDate = paymentDate.toLocaleDateString('en-GB');
                
                row.innerHTML = `
                    <td>${formattedDate}</td>
                    <td>${payment.employer}</td>
                    <td>${payment.worker}</td>
                    <td>â‚¹${payment.amount.toFixed(2)}</td>
                    <td>${payment.purpose}</td>
                    <td>
                        <button class="danger" onclick="deletePayment('${payment.id}')">Delete</button>
                    </td>
                `;
                
                paymentsList.appendChild(row);
            });
        }

        // Update quick summary
        function updateQuickSummary() {
            const summaryDiv = document.getElementById('quickSummary');
            if (!summaryDiv) return;
            
            // Calculate total payments
            const totalAmount = salaryPayments.reduce((sum, payment) => sum + payment.amount, 0);
            
            // Calculate payments by employer
            const employerTotals = {};
            employers.forEach(employer => {
                employerTotals[employer] = salaryPayments
                    .filter(payment => payment.employer === employer)
                    .reduce((sum, payment) => sum + payment.amount, 0);
            });
            
            // Calculate payments to workers
            const workerTotals = {};
            workers.forEach(worker => {
                workerTotals[worker] = salaryPayments
                    .filter(payment => payment.worker === worker)
                    .reduce((sum, payment) => sum + payment.amount, 0);
            });
            
            // Build summary HTML
            let summaryHTML = `
                <div class="summary-item">
                    <strong>Total Payments:</strong> â‚¹${totalAmount.toFixed(2)}
                </div>
                <div class="summary-item">
                    <strong>Total Payments by Employer:</strong>
                    <ul>
            `;
            
            employers.forEach(employer => {
                summaryHTML += `<li>${employer}: â‚¹${employerTotals[employer].toFixed(2)}</li>`;
            });
            
            summaryHTML += `
                    </ul>
                </div>
                <div class="summary-item">
                    <strong>Total Payments to Workers:</strong>
                    <ul>
            `;
            
            workers.forEach(worker => {
                summaryHTML += `<li>${worker}: â‚¹${workerTotals[worker].toFixed(2)}</li>`;
            });
            
            summaryHTML += `
                    </ul>
                </div>
            `;
            
            summaryDiv.innerHTML = summaryHTML;
        }

        // Show detailed expense breakup for a specific worker
        function showWorkerDetail(worker) {
            const workerDetailSection = document.getElementById('workerDetailSection');
            const workerDetailTitle = document.getElementById('workerDetailTitle');
            const workerDetailBody = document.getElementById('workerDetailBody');
            
            // Update title
            workerDetailTitle.textContent = `Expense Breakup for ${worker}`;
            
            // Filter payments for this worker
            const workerPayments = salaryPayments.filter(payment => payment.worker === worker);
            
            // Sort by date (newest first) - handle different date formats
            workerPayments.sort((a, b) => {
                // Convert Firebase Timestamp or Date object to JavaScript Date
                const getDateValue = (payment) => {
                    if (!payment.date) return new Date(0); // Default to epoch if no date
                    
                    if (payment.date instanceof Date) {
                        return payment.date;
                    }
                    
                    // Handle Firebase Timestamp
                    if (payment.date && typeof payment.date.toDate === 'function') {
                        return payment.date.toDate();
                    }
                    
                    // Handle string date or timestamp number
                    return new Date(payment.date);
                };
                
                return getDateValue(b) - getDateValue(a);
            });
            
            // Clear previous content
            workerDetailBody.innerHTML = '';
            
            // Display worker payments
            if (workerPayments.length === 0) {
                const row = document.createElement('tr');
                const cell = document.createElement('td');
                cell.colSpan = 4;
                cell.textContent = 'No payments found for this worker';
                cell.style.textAlign = 'center';
                row.appendChild(cell);
                workerDetailBody.appendChild(row);
            } else {
                workerPayments.forEach(payment => {
                    // Handle different date formats
                    let formattedDate = 'N/A';
                    
                    if (payment.date) {
                        let dateObj;
                        
                        if (payment.date instanceof Date) {
                            dateObj = payment.date;
                        } else if (typeof payment.date.toDate === 'function') {
                            dateObj = payment.date.toDate();
                        } else {
                            dateObj = new Date(payment.date);
                        }
                        
                        formattedDate = `${dateObj.getDate()}/${dateObj.getMonth() + 1}/${dateObj.getFullYear()}`;
                    }
                    
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${formattedDate}</td>
                        <td>${payment.employer || 'Unknown'}</td>
                        <td>â‚¹${typeof payment.amount === 'number' ? payment.amount.toFixed(2) : payment.amount}</td>
                        <td>${payment.purpose || 'N/A'}</td>
                    `;
                    workerDetailBody.appendChild(row);
                });
            }
            
            // Show the detail section
            workerDetailSection.style.display = 'block';
            
            // Hide the summary tables
            document.querySelectorAll('#summaryTab .summary-section').forEach(section => {
                if (section.id !== 'workerDetailSection') {
                    section.style.display = 'none';
                }
            });
        }
        
        // Hide worker detail view and show summary tables
        function hideWorkerDetail() {
            // Hide the detail section
            document.getElementById('workerDetailSection').style.display = 'none';
            
            // Show the summary tables
            document.querySelectorAll('#summaryTab .summary-section').forEach(section => {
                if (section.id !== 'workerDetailSection') {
                    section.style.display = 'block';
                }
            });
        }
        
        // Update summary tables in the Summary tab
        function updateSummaryTables() {
            // Update employer summary table
            const employerSummaryBody = document.getElementById('employerSummaryBody');
            if (!employerSummaryBody) return;
            
            employerSummaryBody.innerHTML = '';
            
            employers.forEach(employer => {
                const totalPaid = salaryPayments
                    .filter(payment => payment.employer === employer)
                    .reduce((sum, payment) => sum + payment.amount, 0);
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${employer}</td>
                    <td>â‚¹${totalPaid.toFixed(2)}</td>
                `;
                employerSummaryBody.appendChild(row);
            });
            
            // Update worker summary table
            const workerSummaryBody = document.getElementById('workerSummaryBody');
            if (!workerSummaryBody) return;
            
            workerSummaryBody.innerHTML = '';
            
            // Create an array of workers with their total received amounts
            const workerTotals = workers.map(worker => {
                const totalReceived = salaryPayments
                    .filter(payment => payment.worker === worker)
                    .reduce((sum, payment) => sum + payment.amount, 0);
                return { worker, totalReceived };
            });
            
            // Sort by total received in decreasing order
            workerTotals.sort((a, b) => b.totalReceived - a.totalReceived);
            
            // Create rows for each worker in sorted order
            workerTotals.forEach(({ worker, totalReceived }) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${worker}</td>
                    <td>â‚¹${totalReceived.toFixed(2)}</td>
                    <td>
                        <button class="secondary" onclick="showWorkerDetail('${worker}')">View Details</button>
                    </td>
                `;
                workerSummaryBody.appendChild(row);
            });
            
            // Update payment matrix table
            const matrixHeader = document.getElementById('paymentMatrixHeader');
            const matrixBody = document.getElementById('paymentMatrixBody');
            if (!matrixHeader || !matrixBody) return;
            
            // Create header row with worker names
            let headerHTML = '<tr><th>Employer \\ Worker</th>';
            workers.forEach(worker => {
                headerHTML += `<th>${worker}</th>`;
            });
            headerHTML += '<th>Total</th></tr>';
            matrixHeader.innerHTML = headerHTML;
            
            // Create matrix body with payment amounts
            matrixBody.innerHTML = '';
            
            employers.forEach(employer => {
                const row = document.createElement('tr');
                let rowHTML = `<td><strong>${employer}</strong></td>`;
                
                let employerTotal = 0;
                
                workers.forEach(worker => {
                    const amount = salaryPayments
                        .filter(payment => payment.employer === employer && payment.worker === worker)
                        .reduce((sum, payment) => sum + payment.amount, 0);
                    
                    employerTotal += amount;
                    rowHTML += `<td>â‚¹${amount.toFixed(2)}</td>`;
                });
                
                rowHTML += `<td><strong>â‚¹${employerTotal.toFixed(2)}</strong></td>`;
                row.innerHTML = rowHTML;
                matrixBody.appendChild(row);
            });
            
            // Add totals row
            const totalsRow = document.createElement('tr');
            let totalsHTML = '<td><strong>Total</strong></td>';
            
            workers.forEach(worker => {
                const workerTotal = salaryPayments
                    .filter(payment => payment.worker === worker)
                    .reduce((sum, payment) => sum + payment.amount, 0);
                
                totalsHTML += `<td><strong>â‚¹${workerTotal.toFixed(2)}</strong></td>`;
            });
            
            const grandTotal = salaryPayments.reduce((sum, payment) => sum + payment.amount, 0);
            totalsHTML += `<td><strong>â‚¹${grandTotal.toFixed(2)}</strong></td>`;
            
            totalsRow.innerHTML = totalsHTML;
            matrixBody.appendChild(totalsRow);
        }

        // Delete a payment
        async function deletePayment(id) {
            if (confirm('Are you sure you want to delete this payment?')) {
                showLoading(true);
                
                try {
                    // Delete from Firebase
                    await salaryCollection.doc(id).delete();
                    
                    // Remove from local array
                    salaryPayments = salaryPayments.filter(payment => payment.id !== id);
                    
                    // Update UI
                    filterAndDisplayPayments();
                    updateQuickSummary();
                    updateSummaryTables();
                    
                    showStatusMessage('Payment deleted successfully from Firebase', 'success');
                } catch (error) {
                    console.error('Error deleting payment from Firebase:', error);
                    showStatusMessage('Error deleting payment: ' + error.message, 'error');
                } finally {
                    showLoading(false);
                }
            }
        }

        // Refresh payments data
        function refreshPayments() {
            loadData();
        }

        // Change page for pagination
        function changePage(direction) {
            const newPage = currentPage + direction;
            if (newPage >= 1 && newPage <= totalPages) {
                currentPage = newPage;
                filterAndDisplayPayments();
            }
        }

        // Change page size
        function changePageSize() {
            const pageSizeElement = document.getElementById('pageSize');
            if (pageSizeElement) {
                pageSize = parseInt(pageSizeElement.value);
                currentPage = 1; // Reset to first page
                filterAndDisplayPayments();
            }
        }

        // Show status message
        function showStatusMessage(message, type) {
            const statusElement = document.getElementById('statusMessage');
            if (!statusElement) return;
            
            statusElement.textContent = message;
            statusElement.className = 'status-message';
            statusElement.classList.add(type);
            statusElement.style.display = 'block';
            
            // Hide after 3 seconds
            setTimeout(() => {
                statusElement.style.display = 'none';
            }, 3000);
        }

        // Show/hide loading overlay
        function showLoading(show = true) {
            const loadingElement = document.getElementById('loadingOverlay');
            if (loadingElement) {
                loadingElement.style.display = show ? 'flex' : 'none';
            }
        }

        // Initialize settlements tab
        function initializeSettlementsTab() {
            // Clear the settlements div
            const settlementsDiv = document.getElementById('settlements');
            if (!settlementsDiv) return;
            
            settlementsDiv.innerHTML = '';

            // Create the toggle control
            const toggleDiv = document.createElement('div');
            toggleDiv.id = 'settlementToggle';
            toggleDiv.className = 'settlement-toggle';
            toggleDiv.innerHTML = `
                <label>
                    <input type="checkbox" id="showAllSettlements" checked 
                        onchange="optimizeSettlements()">
                    Show all possible settlement combinations (uncheck for fewer transactions)
                </label>
            `;

            // Add the toggle to the settlements div
            settlementsDiv.appendChild(toggleDiv);

            // Calculate and display all settlements
            const balances = calculateBalances();
            const settlements = calculateSettlements(balances);
            displaySettlements(settlements);
        }

        // Load settings from localStorage
        function loadSettings() {
            const savedMasterKey = localStorage.getItem('jsonBinMasterKey');
            const savedBinId = localStorage.getItem('jsonBinId');
            const savedPeople = localStorage.getItem('khataTrackerPeople');
            const savedCompletedSettlements = localStorage.getItem('completedSettlements');

            if (savedMasterKey) {
                masterKey = savedMasterKey;
                document.getElementById('jsonBinKey').value = masterKey;
            }

            if (savedBinId) {
                binId = savedBinId;
                document.getElementById('jsonBinId').value = binId;
            }

            if (savedPeople) {
                people = JSON.parse(savedPeople);
            }

            if (savedCompletedSettlements) {
                try {
                    completedSettlements = JSON.parse(savedCompletedSettlements);
                } catch (e) {
                    console.error('Error parsing completed settlements:', e);
                    completedSettlements = [];
                }
            }
        }

        // Save settings
        function saveSettings() {
            const newMasterKey = document.getElementById('jsonBinKey').value.trim();
            const newBinId = document.getElementById('jsonBinId').value.trim();

            if (newMasterKey && newBinId) {
                masterKey = newMasterKey;
                binId = newBinId;

                localStorage.setItem('jsonBinMasterKey', masterKey);
                localStorage.setItem('jsonBinId', binId);

                showStatusMessage('Settings saved successfully', 'success');

                // Reinitialize the app with new settings
                initializeApp();
            } else {
                showStatusMessage('Please fill in all fields', 'error');
            }
        }

        // Test connection to JSONBin
        async function testConnection() {
            showLoading(true);

            try {
                const headers = getHeaders();

                const response = await fetch(`${JSON_BIN_URL}/${binId}/latest`, {
                    method: 'GET',
                    headers: headers
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }

                await response.json();
                showStatusMessage('Connection successful! Your settings are working correctly.', 'success');
            } catch (error) {
                console.error('Connection test error:', error);
                showStatusMessage('Connection failed: ' + error.message, 'error');
            } finally {
                showLoading(false);
            }
        }

        // Show/hide loading overlay
        function showLoading(show) {
            document.getElementById('loadingOverlay').style.display = show ? 'flex' : 'none';
        }

        // Initialize the application
        async function initializeApp() {
            showLoading(true);

            try {
                // Update UI with current people
                updatePeopleUI();

                // Try to fetch existing data
                const response = await fetch(`${JSON_BIN_URL}/${binId}/latest`, {
                    method: 'GET',
                    headers: getHeaders()
                });

                if (!response.ok) {
                    throw new Error(`Failed to fetch data: ${response.status}`);
                }

                const data = await response.json();

                // Check if data has the expected structure
                if (data && data.record) {
                    // Extract salary payments, employers and workers from the response
                    if (Array.isArray(data.record.salaryPayments)) {
                        salaryPayments = data.record.salaryPayments;
                    } else {
                        salaryPayments = [];
                    }

                    // If employers and workers are in the response, use them
                    if (Array.isArray(data.record.employers)) {
                        employers = data.record.employers;
                        // Save employers to localStorage as backup
                        localStorage.setItem('salaryTrackerEmployers', JSON.stringify(employers));
                    }
                    
                    if (Array.isArray(data.record.workers)) {
                        workers = data.record.workers;
                        // Save workers to localStorage as backup
                        localStorage.setItem('salaryTrackerWorkers', JSON.stringify(workers));
                    }
                    
                    // Update UI with current employers and workers
                    initializeUI();

                    // Update UI
                    filterAndDisplayPayments();
                    updateQuickSummary();
                    showStatusMessage('Data loaded successfully', 'success');
                } else {
                    // Initialize with empty data
                    await initializeData();
                }
            } catch (error) {
                console.error('Error initializing app:', error);
                showStatusMessage('Error loading data. Using local storage.', 'error');

                // Try to load from localStorage as fallback
                loadFromLocalStorage();

                // Mark that we're using localStorage
                usingLocalStorage = true;
            } finally {
                showLoading(false);
            }
        }

        // Initialize data structure in JSONBin
        async function initializeData() {
            // Create initial data structure specific to salary tracker
            const initialData = {
                salaryPayments: []
            };

            try {
                const response = await fetch(`${JSON_BIN_URL}/${binId}`, {
                    method: 'PUT',
                    headers: getHeaders(),
                    body: JSON.stringify(initialData)
                });

                if (!response.ok) {
                    throw new Error(`Failed to initialize data: ${response.status}`);
                }

                salaryPayments = [];
                filterAndDisplayPayments();
                updateQuickSummary();
                showStatusMessage('Data initialized successfully', 'success');
            } catch (error) {
                console.error('Error initializing data:', error);
                showStatusMessage('Error initializing data. Using local storage.', 'error');

                // Mark that we're using localStorage
                usingLocalStorage = true;
            }
        }

        // Load data from localStorage
        function loadFromLocalStorage() {
            try {
                const savedPayments = localStorage.getItem('salaryPayments');
                if (savedPayments) {
                    salaryPayments = JSON.parse(savedPayments);
                    
                    // Convert date strings back to Date objects for proper sorting
                    salaryPayments.forEach(payment => {
                        if (typeof payment.date === 'string') {
                            payment.date = new Date(payment.date);
                        }
                    });
                    
                    usingLocalStorage = true;
                    filterAndDisplayPayments();
                    updateQuickSummary();
                    showStatusMessage('Data loaded from local storage', 'success');
                } else {
                    salaryPayments = [];
                    filterAndDisplayPayments();
                    updateQuickSummary();
                }
            } catch (error) {
                console.error('Error loading from localStorage:', error);
                salaryPayments = [];
                filterAndDisplayPayments();
                updateQuickSummary();
            }
        }

        // Save data to Firebase
        async function saveData() {
            // We don't need to save to localStorage anymore
            // as we're using Firebase for persistent storage
            
            showLoading(true);

            try {
                // We don't need to save the entire data structure at once
                // Firebase will handle individual documents
                
                // For now, we'll just show a success message
                // The actual saving happens in addSalaryPayment and other functions
                
                showStatusMessage('Data saved successfully to Firebase', 'success');
            } catch (error) {
                console.error('Error saving data:', error);
                showStatusMessage('Error saving data: ' + error.message, 'error');
            } finally {
                showLoading(false);
            }
        }

        // Save to localStorage as backup
        function saveToLocalStorage() {
            localStorage.setItem('salaryPayments', JSON.stringify(salaryPayments));
            // Save employers and workers lists if needed
            localStorage.setItem('salaryTrackerEmployers', JSON.stringify(employers));
            localStorage.setItem('salaryTrackerWorkers', JSON.stringify(workers));
        }

        // Get headers for JSONBin requests
        function getHeaders() {
            return {
                'Content-Type': 'application/json',
                'X-Master-Key': masterKey
            };
        }

        // Show status message
        function showStatusMessage(message, type) {
            const statusMessage = document.getElementById('statusMessage');
            statusMessage.textContent = message;
            statusMessage.className = `status-message ${type}`;
            statusMessage.style.display = 'block';

            // Hide message after 3 seconds
            setTimeout(() => {
                statusMessage.style.display = 'none';
            }, 3000);
        }

        // Update expense UI (payer dropdown, split checkboxes, transactions table, balances)
        function updateExpenseUI() {
            // Update payer dropdown
            const payerSelect = document.getElementById('payer');
            if (!payerSelect) {
                // Element doesn't exist, which is expected in salary tracker
                return; // Exit the function early
            }
            
            payerSelect.innerHTML = '';

            people.forEach(person => {
                const option = document.createElement('option');
                option.value = person;
                option.textContent = person;
                payerSelect.appendChild(option);
            });

            // Update split between checkboxes
            updateSplitBetweenCheckboxes();

            // Reset filters
            document.getElementById('transactionSearch').value = '';
            document.getElementById('transactionDateFilter').value = 'all';

            // Reset pagination
            currentPage = 1;

            // Update filtered transactions and display
            filterAndDisplayTransactions();

            // Update balances and settlements
            updateBalancesAndSettlements();
        }

        // Update split between checkboxes
        function updateSplitBetweenCheckboxes() {
            const splitBetweenDiv = document.getElementById('splitBetweenCheckboxes');
            splitBetweenDiv.innerHTML = '';

            people.forEach(person => {
                const checkboxItem = document.createElement('div');
                checkboxItem.className = 'checkbox-item';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `split${person}`;
                checkbox.value = person;
                checkbox.checked = true;

                const label = document.createElement('label');
                label.htmlFor = `split${person}`;
                label.textContent = person;

                checkboxItem.appendChild(checkbox);
                checkboxItem.appendChild(label);
                splitBetweenDiv.appendChild(checkboxItem);
            });
        }

        // Update people UI
        function updatePeopleUI() {
            const peopleList = document.getElementById('peopleList');
            if (!peopleList) {
                // Element doesn't exist, which is expected in salary tracker
                return; // Exit the function early
            }
            
            peopleList.innerHTML = '';

            people.forEach(person => {
                const personTag = document.createElement('div');
                personTag.className = 'person-tag';

                personTag.innerHTML = `
                    ${person}
                    <button onclick="removePerson('${person}')">&times;</button>
                `;

                peopleList.appendChild(personTag);
            });
        }

        // Add a new person
        function addPerson() {
            const newPersonInput = document.getElementById('newPersonName');
            const newPersonName = newPersonInput.value.trim();

            if (!newPersonName) {
                showStatusMessage('Please enter a name', 'error');
                return;
            }

            if (people.includes(newPersonName)) {
                showStatusMessage('This person already exists', 'error');
                return;
            }

            people.push(newPersonName);

            // Update UI
            updatePeopleUI();
            updateExpenseUI();

            // Save data
            saveData();

            // Clear input
            newPersonInput.value = '';

            showStatusMessage(`${newPersonName} added successfully`, 'success');
        }

        // Remove a person
        function removePerson(personName) {
            // Check if person has transactions
            const hasTransactions = transactions.some(t =>
                t.payer === personName || t.splitBetween.includes(personName)
            );

            let confirmMessage = `Are you sure you want to remove ${personName}?`;

            if (hasTransactions) {
                confirmMessage += ` This person has transactions. Removing them will affect balance calculations.`;
            }

            if (confirm(confirmMessage)) {
                people = people.filter(p => p !== personName);

                // Update UI
                updatePeopleUI();
                updateExpenseUI();

                // Save data
                saveData();

                showStatusMessage(`${personName} removed successfully`, 'success');
            }
        }

        // Add a new expense
        function addExpense() {
            const payer = document.getElementById('payer').value;
            const amount = parseFloat(document.getElementById('amount').value);
            const description = document.getElementById('description').value;

            // Get selected people for splitting
            const splitBetween = [];
            people.forEach(person => {
                const checkbox = document.getElementById(`split${person}`);
                if (checkbox && checkbox.checked) {
                    splitBetween.push(person);
                }
            });

            // Validation
            if (!payer) {
                showStatusMessage('Please select who paid', 'error');
                return;
            }

            if (isNaN(amount) || amount <= 0) {
                showStatusMessage('Please enter a valid amount', 'error');
                return;
            }

            if (!description) {
                showStatusMessage('Please enter a description', 'error');
                return;
            }

            if (splitBetween.length === 0) {
                showStatusMessage('Please select at least one person to split with', 'error');
                return;
            }

            // Format date as dd/mm/yyyy
            const today = new Date();
            const day = String(today.getDate()).padStart(2, '0');
            const month = String(today.getMonth() + 1).padStart(2, '0'); // January is 0!
            const year = today.getFullYear();
            const formattedDate = `${day}/${month}/${year}`;

            // Create new transaction
            const newTransaction = {
                id: Date.now(),
                date: formattedDate,
                payer: payer,
                amount: amount,
                description: description,
                splitBetween: splitBetween
            };

            // Add to transactions array
            transactions.push(newTransaction);

            // Save data
            saveData();

            // Update UI
            filterAndDisplayTransactions();
            updateBalancesAndSettlements();

            // Reset form
            document.getElementById('amount').value = '';
            document.getElementById('description').value = '';

            showStatusMessage('Expense added successfully', 'success');
        }

        // Filter and display transactions - stub function for compatibility
        function filterAndDisplayTransactions() {
            // This is a stub function to prevent errors
            // In the salary tracker, we use filterAndDisplayPayments instead
            console.log("filterAndDisplayTransactions called - this is a stub function");
            return;

            // Apply filters
            filteredTransactions = [...transactions];

            // Apply search filter
            if (searchTerm) {
                filteredTransactions = filteredTransactions.filter(transaction => {
                    return transaction.description.toLowerCase().includes(searchTerm) ||
                        transaction.payer.toLowerCase().includes(searchTerm) ||
                        transaction.splitBetween.some(person => person.toLowerCase().includes(searchTerm));
                });
            }

            // Apply date filter
            if (dateFilter !== 'all') {
                const today = new Date();
                today.setHours(0, 0, 0, 0);

                filteredTransactions = filteredTransactions.filter(transaction => {
                    // Parse dd/mm/yyyy format to Date object
                    const [day, month, year] = transaction.date.split('/').map(Number);
                    const transactionDate = new Date(year, month - 1, day);

                    if (dateFilter === 'today') {
                        return transactionDate.getTime() === today.getTime();
                    } else if (dateFilter === 'week') {
                        const weekAgo = new Date(today);
                        weekAgo.setDate(today.getDate() - 7);
                        return transactionDate >= weekAgo;
                    } else if (dateFilter === 'month') {
                        const monthAgo = new Date(today);
                        monthAgo.setMonth(today.getMonth() - 1);
                        return transactionDate >= monthAgo;
                    }
                    return true;
                });
            }

            // Sort by date (newest first)
            filteredTransactions.sort((a, b) => {
                // Parse dd/mm/yyyy format to Date objects for comparison
                const [aDay, aMonth, aYear] = a.date.split('/').map(Number);
                const [bDay, bMonth, bYear] = b.date.split('/').map(Number);

                const dateA = new Date(aYear, aMonth - 1, aDay);
                const dateB = new Date(bYear, bMonth - 1, bDay);

                return dateB - dateA;
            });

            // Display payments with pagination
            filterAndDisplayPayments();
        }

        // This function has been removed as it was using undefined variables
        // and was replaced with filterAndDisplayPayments()

        // Change page
        function changePage(direction) {
            currentPage += direction;
            filterAndDisplayPayments();
        }

        // Change page size
        function changePageSize() {
            pageSize = parseInt(document.getElementById('pageSize').value);
            currentPage = 1;
            filterAndDisplayPayments();
        }

        // Update quick summary
        function updateQuickSummary() {
            const summaryDiv = document.getElementById('quickSummary');
            summaryDiv.innerHTML = '';

            // Total transactions
            const totalAmount = salaryPayments.reduce((sum, t) => sum + t.amount, 0);

            // Create summary elements
            const totalTransactionsEl = document.createElement('div');
            totalTransactionsEl.className = 'summary-item';
            totalTransactionsEl.innerHTML = `<strong>Total Transactions:</strong> ${salaryPayments.length}`;

            const totalAmountEl = document.createElement('div');
            totalAmountEl.className = 'summary-item';
            totalAmountEl.innerHTML = `<strong>Total Amount:</strong> â‚¹${totalAmount.toFixed(2)}`;

            // Add to summary
            summaryDiv.appendChild(totalTransactionsEl);
            summaryDiv.appendChild(totalAmountEl);

            // Add top spender if we have salary payments
            if (salaryPayments.length > 0) {
                // Calculate spending by employer
                const spendingByPerson = {};
                employers.forEach(employer => spendingByPerson[employer] = 0);

                salaryPayments.forEach(payment => {
                    spendingByPerson[payment.employer] = (spendingByPerson[payment.employer] || 0) + payment.amount;
                });

                // Find top employer (who paid the most)
                let topSpender = employers[0];
                employers.forEach(employer => {
                    if (spendingByPerson[employer] > spendingByPerson[topSpender]) {
                        topSpender = employer;
                    }
                });

                const topSpenderEl = document.createElement('div');
                topSpenderEl.className = 'summary-item';
                topSpenderEl.innerHTML = `<strong>Top Employer:</strong> ${topSpender} (â‚¹${spendingByPerson[topSpender].toFixed(2)})`;

                summaryDiv.appendChild(topSpenderEl);
            }
        }

        // This function has been replaced by deletePayment
        function deleteTransaction(id) {
            // Redirect to the correct function
            deletePayment(id);
        }

        // Clear all salary payments
        async function clearAllTransactions() {
            if (confirm('Are you sure you want to clear ALL salary payments? This cannot be undone!')) {
                showLoading(true);
                
                try {
                    // Get all documents in the collection
                    const snapshot = await salaryCollection.get();
                    
                    // Delete each document
                    const batch = db.batch();
                    snapshot.forEach(doc => {
                        batch.delete(doc.ref);
                    });
                    
                    // Commit the batch
                    await batch.commit();
                    
                    // Clear local array
                    salaryPayments = [];
                    
                    // Update UI
                    filterAndDisplayPayments();
                    updateQuickSummary();
                    
                    showStatusMessage('All salary payments cleared successfully from Firebase', 'success');
                } catch (error) {
                    console.error('Error clearing payments from Firebase:', error);
                    showStatusMessage('Error clearing payments: ' + error.message, 'error');
                } finally {
                    showLoading(false);
                }
            }
        }

        // Refresh transactions from server
        async function refreshTransactions() {
            showLoading(true);

            try {
                const response = await fetch(`${JSON_BIN_URL}/${binId}/latest`, {
                    method: 'GET',
                    headers: getHeaders()
                });

                if (!response.ok) {
                    throw new Error(`Failed to fetch data: ${response.status}`);
                }

                const data = await response.json();

                // Check if data has the expected structure
                if (data && data.record) {
                    // Extract transactions and people from the response
                    if (Array.isArray(data.record.transactions)) {
                        transactions = data.record.transactions;
                    }

                    if (Array.isArray(data.record.people)) {
                        people = data.record.people;
                        // Save people to localStorage as backup
                        localStorage.setItem('khataTrackerPeople', JSON.stringify(people));
                        // Update UI with current people
                        updatePeopleUI();
                    }

                    // Update UI
                    updateExpenseUI();
                    showStatusMessage('Data refreshed successfully', 'success');

                    // Reset localStorage flag
                    usingLocalStorage = false;
                } else {
                    throw new Error('Invalid data structure');
                }
            } catch (error) {
                console.error('Error refreshing data:', error);
                showStatusMessage('Error refreshing data: ' + error.message, 'error');
            } finally {
                showLoading(false);
            }
        }

        // Calculate and update balances and settlements - stub function for compatibility
        function updateBalancesAndSettlements() {
            // This is a stub function to prevent errors
            // In the salary tracker, we don't need this functionality
            console.log("updateBalancesAndSettlements called - this is a stub function");
            return;
        }

        // Calculate balances for all people
        function calculateBalances() {
            // Initialize balances for all people
            const balances = {};
            people.forEach(person => {
                balances[person] = 0;
            });

            // Calculate each person's contribution and share
            transactions.forEach(transaction => {
                const payer = transaction.payer;
                const amount = transaction.amount;
                const splitBetween = transaction.splitBetween;

                // Skip if no one to split with
                if (splitBetween.length === 0) return;

                const sharePerPerson = amount / splitBetween.length;

                // Add the full amount to the payer (what they're owed)
                if (balances[payer] !== undefined) {
                    balances[payer] += amount;
                }

                // Subtract each person's share (what they owe)
                splitBetween.forEach(person => {
                    if (balances[person] !== undefined) {
                        balances[person] -= sharePerPerson;
                    }
                });
            });

            // Round balances to 2 decimal places to avoid floating point issues
            for (const person in balances) {
                balances[person] = parseFloat(balances[person].toFixed(2));
            }

            return balances;
        }

        // Display individual balances
        function displayBalances(balances) {
            const balancesDiv = document.getElementById('balances');
            balancesDiv.innerHTML = '';

            // Create a table for balances
            const balanceTable = document.createElement('table');
            balanceTable.innerHTML = `
                                            <thead>
                                                <tr>
                                                    <th>Person</th>
                                                    <th>Balance</th>
                                                    <th>Status</th>
                                                </tr>
                                            </thead>
                                            <tbody></tbody>
                                        `;

            const tableBody = balanceTable.querySelector('tbody');

            // Sort people by balance (highest to lowest)
            const sortedPeople = [...people].sort((a, b) => {
                return (balances[b] || 0) - (balances[a] || 0);
            });

            sortedPeople.forEach(person => {
                if (balances[person] !== undefined) {
                    const balance = balances[person];
                    const balanceClass = balance >= 0 ? 'positive' : 'negative';
                    const status = balance > 0 ? 'Is owed money' :
                        balance < 0 ? 'Owes money' : 'Settled up';

                    const row = document.createElement('tr');
                    row.innerHTML = `
                                                    <td><strong>${person}</strong></td>
                                                    <td class="${balanceClass}">â‚¹${balance.toFixed(2)}</td>
                                                    <td>${status}</td>
                                                `;
                    tableBody.appendChild(row);
                }
            });

            balancesDiv.appendChild(balanceTable);

            // Add a total row
            const totalPositive = Object.values(balances)
                .filter(b => b > 0)
                .reduce((sum, b) => sum + b, 0);

            const totalElement = document.createElement('p');
            totalElement.className = 'balance-total';
            totalElement.innerHTML = `<strong>Total Money Owed: <span class="positive">â‚¹${totalPositive.toFixed(2)}</span></strong>`;
            balancesDiv.appendChild(totalElement);

            // Add explanation
            const explanation = document.createElement('div');
            explanation.className = 'settlement-explanation';
            explanation.innerHTML = `
                                            <p><strong>Understanding Balances:</strong></p>
                                            <ul>
                                                <li><span class="positive">Positive balance</span>: This person is owed money by others</li>
                                                <li><span class="negative">Negative balance</span>: This person owes money to others</li>
                                                <li>Zero balance: This person is settled up</li>
                                            </ul>
                                        `;
            balancesDiv.appendChild(explanation);
        }

        // For backward compatibility
        function updateBalances() {
            updateBalancesAndSettlements();
        }

        // Calculate all possible settlements between members
        function calculateSettlements(balances) {
            const settlements = [];

            // Create a matrix of all possible settlements between members
            // We'll use the balances directly instead of recalculating from transactions
            for (let i = 0; i < people.length; i++) {
                for (let j = 0; j < people.length; j++) {
                    // Skip self-settlements
                    if (i === j) continue;

                    const person1 = people[i];
                    const person2 = people[j];

                    // Only create settlements where one person has positive balance
                    // and the other has negative balance
                    if (balances[person1] > 0 && balances[person2] < 0) {
                        // person2 (negative balance) owes person1 (positive balance)
                        // Calculate the maximum amount that can be settled
                        const maxAmount = Math.min(balances[person1], Math.abs(balances[person2]));

                        if (maxAmount > 0.01) {
                            settlements.push({
                                from: person2,  // The person who owes (negative balance)
                                to: person1,    // The person who is owed (positive balance)
                                amount: parseFloat(maxAmount.toFixed(2)),
                                completed: false
                            });
                        }
                    }
                }
            }

            // Sort settlements by amount (highest first)
            settlements.sort((a, b) => b.amount - a.amount);

            return settlements;
        }

        // Display settlements
        function displaySettlements(settlements) {
            const settlementsDiv = document.getElementById('settlements');

            // Keep the toggle if it exists
            const existingToggle = document.getElementById('settlementToggle');
            settlementsDiv.innerHTML = '';
            if (existingToggle) {
                settlementsDiv.appendChild(existingToggle);
            }

            if (settlements.length === 0) {
                const noSettlementsMsg = document.createElement('p');
                noSettlementsMsg.textContent = 'No settlements needed. Everyone is square!';
                settlementsDiv.appendChild(noSettlementsMsg);
                return;
            }

            // Mark settlements as completed if they're in the completedSettlements array
            settlements.forEach(settlement => {
                const isCompleted = completedSettlements.some(
                    cs => cs.from === settlement.from &&
                        cs.to === settlement.to &&
                        Math.abs(cs.amount - settlement.amount) < 0.01
                );

                settlement.completed = isCompleted;
            });

            // Create a summary section for all possible combinations
            const allCombinationsSection = document.createElement('div');
            allCombinationsSection.className = 'settlement-section';

            const combinationsHeader = document.createElement('h4');
            combinationsHeader.textContent = 'All Possible Settlement Combinations';
            allCombinationsSection.appendChild(combinationsHeader);

            const combinationsTable = document.createElement('table');
            combinationsTable.innerHTML = `
                                            <thead>
                                                <tr>
                                                    <th>From</th>
                                                    <th>To</th>
                                                    <th>Amount</th>
                                                    <th>Status</th>
                                                </tr>
                                            </thead>
                                            <tbody id="combinationsTableBody"></tbody>
                                        `;

            const tableBody = combinationsTable.querySelector('tbody');

            settlements.forEach((settlement, index) => {
                const row = document.createElement('tr');
                row.className = settlement.completed ? 'settlement-completed' : '';

                row.innerHTML = `
                                                <td>${settlement.from}</td>
                                                <td>${settlement.to}</td>
                                                <td class="negative">â‚¹${settlement.amount.toFixed(2)}</td>
                                                <td>
                                                    <input type="checkbox" id="settlement-table-${index}" 
                                                        ${settlement.completed ? 'checked' : ''} 
                                                        onchange="toggleSettlementStatus(${index})">
                                                    <label for="settlement-table-${index}">
                                                        ${settlement.completed ? 'Completed' : 'Pending'}
                                                    </label>
                                                </td>
                                            `;

                tableBody.appendChild(row);
            });

            allCombinationsSection.appendChild(combinationsTable);
            settlementsDiv.appendChild(allCombinationsSection);

            // Group settlements by person
            const settlementsByPerson = {};

            people.forEach(person => {
                settlementsByPerson[person] = {
                    owes: [],    // What this person owes to others
                    owed: []     // What others owe to this person
                };
            });

            // Populate the grouped settlements
            settlements.forEach((settlement, index) => {
                // Add to what the person owes
                if (settlementsByPerson[settlement.from]) {
                    settlementsByPerson[settlement.from].owes.push({
                        ...settlement,
                        index
                    });
                }

                // Add to what the person is owed
                if (settlementsByPerson[settlement.to]) {
                    settlementsByPerson[settlement.to].owed.push({
                        ...settlement,
                        index
                    });
                }
            });

            // Create a section header for individual settlements
            const individualHeader = document.createElement('h3');
            individualHeader.textContent = 'Individual Settlements';
            individualHeader.style.marginTop = '30px';
            settlementsDiv.appendChild(individualHeader);

            // Create a section for each person
            people.forEach(person => {
                const personSettlements = settlementsByPerson[person];

                // Skip if no settlements for this person
                if (personSettlements.owes.length === 0 && personSettlements.owed.length === 0) {
                    return;
                }

                // Create person section
                const personSection = document.createElement('div');
                personSection.className = 'settlement-section';

                // Add person header
                const personHeader = document.createElement('h4');
                personHeader.textContent = person;
                personSection.appendChild(personHeader);

                // Add what this person owes
                if (personSettlements.owes.length > 0) {
                    const owesHeader = document.createElement('h5');
                    owesHeader.textContent = `${person} owes:`;
                    personSection.appendChild(owesHeader);

                    personSettlements.owes.forEach(settlement => {
                        const settlementCard = createSettlementCard(settlement, settlement.index);
                        personSection.appendChild(settlementCard);
                    });
                }

                // Add what this person is owed
                if (personSettlements.owed.length > 0) {
                    const owedHeader = document.createElement('h5');
                    owedHeader.textContent = `Owed to ${person}:`;
                    personSection.appendChild(owedHeader);

                    personSettlements.owed.forEach(settlement => {
                        const settlementCard = createSettlementCard(settlement, settlement.index);
                        personSection.appendChild(settlementCard);
                    });
                }

                // Add to main settlements div
                settlementsDiv.appendChild(personSection);
            });
        }

        // Create a settlement card element
        function createSettlementCard(settlement, index) {
            const settlementCard = document.createElement('div');
            settlementCard.className = `settlement-card ${settlement.completed ? 'settlement-completed' : ''}`;

            const checkboxId = `settlement-${index}`;

            settlementCard.innerHTML = `
                                            <div>
                                                <input type="checkbox" id="${checkboxId}" 
                                                    ${settlement.completed ? 'checked' : ''} 
                                                    onchange="toggleSettlementStatus(${index})">
                                                <label for="${checkboxId}">
                                                    ${settlement.from} should pay ${settlement.to}
                                                </label>
                                            </div>
                                            <div class="settlement-amount negative">â‚¹${settlement.amount.toFixed(2)}</div>
                                        `;

            return settlementCard;
        }

        // Toggle settlement completion status
        function toggleSettlementStatus(index) {
            // Get current balances
            const balances = calculateBalances();

            // Calculate settlements
            const settlements = calculateSettlements(balances);

            if (index >= 0 && index < settlements.length) {
                const settlement = settlements[index];

                // Check if this settlement is already in completedSettlements
                const existingIndex = completedSettlements.findIndex(
                    cs => cs.from === settlement.from &&
                        cs.to === settlement.to &&
                        Math.abs(cs.amount - settlement.amount) < 0.01
                );

                if (existingIndex >= 0) {
                    // Remove from completed settlements
                    completedSettlements.splice(existingIndex, 1);
                } else {
                    // Add to completed settlements
                    completedSettlements.push({
                        from: settlement.from,
                        to: settlement.to,
                        amount: settlement.amount,
                        date: new Date().toLocaleDateString('en-GB')
                    });
                }

                // Save completed settlements to backend
                saveData();

                // Update display
                displaySettlements(settlements);
            }
        }

        // Toggle between showing all settlements and optimized settlements
        function optimizeSettlements() {
            // Calculate current balances
            const balances = calculateBalances();

            // Get the toggle checkbox
            const toggleCheckbox = document.getElementById('showAllSettlements');

            // If the toggle doesn't exist yet, create it
            if (!toggleCheckbox) {
                // Create the toggle first
                const settlementsDiv = document.getElementById('settlements');
                const toggleDiv = document.createElement('div');
                toggleDiv.id = 'settlementToggle';
                toggleDiv.className = 'settlement-toggle';
                toggleDiv.innerHTML = `
                                                <label>
                                                    <input type="checkbox" id="showAllSettlements" checked 
                                                        onchange="optimizeSettlements()">
                                                    Show all possible settlement combinations
                                                </label>
                                            `;

                // Insert at the top of settlements div
                settlementsDiv.insertBefore(toggleDiv, settlementsDiv.firstChild);

                // Show all settlements by default
                const settlements = calculateSettlements(balances);
                displaySettlements(settlements);
                return;
            }

            // Get the current state
            const showingAll = toggleCheckbox.checked;

            // Display the appropriate settlements
            if (showingAll) {
                // Show all settlements
                const settlements = calculateSettlements(balances);
                displaySettlements(settlements);
                showStatusMessage('Showing all possible settlement combinations', 'success');
            } else {
                // Show optimized settlements
                const settlements = calculateOptimizedSettlements(balances);
                displaySettlements(settlements);
                showStatusMessage('Showing optimized settlements (fewer transactions)', 'success');
            }
        }

        // Calculate optimized settlements (minimum number of transactions)
        function calculateOptimizedSettlements(balances) {
            // Create arrays of creditors (positive balance) and debtors (negative balance)
            const creditors = [];
            const debtors = [];

            // Make a copy of balances to avoid modifying the original
            const balancesCopy = { ...balances };

            for (const person in balancesCopy) {
                const balance = balancesCopy[person];
                if (balance > 0.01) {
                    creditors.push({ name: person, amount: balance });
                } else if (balance < -0.01) {
                    debtors.push({ name: person, amount: balance });
                }
            }

            // Sort by amount (largest first)
            creditors.sort((a, b) => b.amount - a.amount);
            debtors.sort((a, b) => a.amount - b.amount); // Most negative first

            const settlements = [];

            // Try to match largest debtor with largest creditor first
            // This minimizes the number of transactions needed
            while (debtors.length > 0 && creditors.length > 0) {
                const debtor = debtors[0];
                const creditor = creditors[0];

                // Calculate settlement amount
                const amount = Math.min(Math.abs(debtor.amount), creditor.amount);
                const roundedAmount = parseFloat(amount.toFixed(2));

                if (roundedAmount > 0.01) {
                    // Add settlement
                    settlements.push({
                        from: debtor.name,
                        to: creditor.name,
                        amount: roundedAmount,
                        completed: false
                    });
                }

                // Update balances
                debtor.amount += roundedAmount;
                creditor.amount -= roundedAmount;

                // Remove people with zero balance
                if (Math.abs(debtor.amount) < 0.01) {
                    debtors.shift();
                }

                if (Math.abs(creditor.amount) < 0.01) {
                    creditors.shift();
                }
            }

            return settlements;
        }

        // Record a settlement manually
        function recordSettlement() {
            // Implementation for recording a manual settlement
            // This could be expanded with a modal dialog
            alert('This feature will be implemented in a future update.');
        }
    </script>
</body>

</html>